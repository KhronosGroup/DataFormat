// Copyright (c) 2014-2025 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html
[[UASTC]]
== Universal ASTC Compressed Texture Images

_UASTC was created by Rich Geldreich, who has placed the design in the public
domain._

=== Introduction

UASTC is a 19-mode 4{times}4 pixel LDR-only subset of the ASTC specification
with a simpler 128-bit block format.
It can be quickly, losslessly transcoded to the standard
<<ASTC,ASTC block format>>, quickly transcoded to <<bptc_bc7,BC7>> with very
low quality loss (within around .75-1.5 _RGB_ dB PSNR), or re-encoded to high
quality <<etc1,ETC1>>, <<RGBAETC2,ETC1 with A8>>, or <<S3TC,BC1-5>> with a
small amount of per-pixel work.
There are 9 opaque modes, 1 solid-color mode, and 9 modes with alpha support.
These UASTC modes each map to one of 6 BC7 modes (all except 0 and 4).

UASTC is the first high quality universal (or virtual) block-based texture
format that supports block partitioning along with the ability to be
efficiently transcoded to multiple GPU texture formats.
Transcoding can either be done using the CPU or with a GPU compute shader.
Transcoding UASTC to ASTC and BC7 do not involve any pixel-level operations.
UASTC's fields directly correspond to ASTC's fields whenever possible.

The UASTC block format has hint bits to accelerate UASTC transcoding to various
texture formats.
There are up to two BC1 hint bits per block which direct the UASTC{rarrow}BC1
transcoder to reuse the UASTC endpoint and/or weight indices (appropriately
mapped) for faster real-time compression.
On average \~60% of UASTC blocks don't need PCA, and ~30% don't need real-time
BC1 encoding at all.
There are also hint bits to accelerate transcoding to high quality ETC1 and
ETC2 EAC A8.

[[uastc-bitstream-format]]
=== Bitstream format

Bits are described in order from the start of the block (the first
byte's least-significant bit) working ``down'' towards bit 127.
Each block may contain the following fields, the exact layout of which
depends on the _Mode Index_ value.

* *MODE* Value that defines the block's layout and decoding strategy.

* *_R_, _G_, _B_, and _A_* Solid color value (only for _Mode Index_ 8).

* *BC1H0 and BC1H1* BC1 transcoding acceleration hints.
  See <<uastc_transcode_etc,Transcoding to BC1>> for details.

* *ETC** ETC1/EAC transcoding acceleration hints.
  See <<uastc_transcode_etc,Transcoding to ETC>> for details.

* *CSEL* Color Component Selector field.
  Indicates which color channel uses the second set of interpolation weights
  (only for dual-plane modes).

* *PAT* Index into a mode-specific partition pattern table.
  There are three tables and 60 total partition patterns.

* *ET[]* Packed endpoint trits values.
  Depending on the _Mode Index_, there could be 0, 2, or 4 *ET* elements.

* *EQ[]* Packed endpoint quints values.
  Depending on the _Mode Index_, there could be 0, 2, or 4 *EQ* elements.

* *_RL0_, _RH0_, _RL1_, _RH1_, _RL2_, _RH2_* Red endpoint bits.

* *_GL0_, _GH0_, _GL1_, _GH1_, _GL2_, _GH2_* Green endpoint bits.

* *_BL0_, _BH0_, _BL1_, _BH1_, _BL2_, _BH2_* Blue endpoint bits.

* *_AL0_, _AH0_, _AL1_, _AH1_* Alpha endpoint bits.

* *_LL0_, _LH0_, _LL1_, _LH1_* Luminance endpoint bits.

* *WEIGHTS0[i] and WEIGHTS1[i]* Weight indices for planes 0 and 1, texel
  i = 4 {times} y + x.
  WEIGHTS1 is present only in dual-plane modes.
  Each array has 16 elements.

NOTE: Just like BC7, the first weight index of each subset's ``anchor''
pixel always has a most-significant bit of 0, so these weights can be
encoded with one fewer bit than the others.
In dual-plane modes (which are always one subset), the first two weight
indices must have a most-significant bit of 0.

Unassigned bits must be zero.

=== Mode Index

A Huffman-coded mode field is always first and is stored starting at bit
0 of the block (bit 0 of byte 0); it takes from 2 to 7 bits.
The _Mode Index_ range is [0..19].
The last _Mode Index_ (19) is reserved for possible future expansion
and should be decoded to the error color (255, 0, 255, 255).
The encoding of each _Mode Index_ is defined in
<<uastc-mode-index-encoding>>.

[[uastc-mode-index-encoding]]
.UASTC _Mode Index_ encoding
[options="header",width="50%"]
|===============
| _Mode Bits_ | _Mode Value_ | Encoding Bit Length | _Mode Index_
| xxxxx00     | 0x00         | 2                   | 11
| xxxx010     | 0x02         | 3                   | 10
| xxxx110     | 0x06         | 3                   | 12
| xxx0001     | 0x01         | 4                   | 0
| xxx1001     | 0x09         | 4                   | 18
| xx00011     | 0x03         | 5                   | 3
| xx00111     | 0x07         | 5                   | 7
| xx01011     | 0x0B         | 5                   | 5
| xx01101     | 0x0D         | 5                   | 14
| xx01111     | 0x0F         | 5                   | 9
| xx10011     | 0x13         | 5                   | 4
| xx10111     | 0x17         | 5                   | 8
| xx11011     | 0x1B         | 5                   | 6
| xx11101     | 0x1D         | 5                   | 2
| xx11111     | 0x1F         | 5                   | 13
| x010101     | 0x15         | 6                   | 16
| x100101     | 0x25         | 6                   | 17
| x110101     | 0x35         | 6                   | 1
| 0000101     | 0x05         | 7                   | 15
| 1000101     | 0x45         | 7                   | 19
|===============

If the _Mode Bits_ do not match any _Mode Index_ value, the block is
invalid and decodes to the error color (255, 0, 255, 255).

=== Solid color blocks

Blocks representing solid color use _Mode Index_ 8 and are encoded
in the consecutive bit allocations shown from top to bottom in
<<uastc-solid-block-bits>>, starting at the least significant bit
in the block.

[[uastc-solid-block-bits]]
.UASTC bit interpretations for solid color blocks
[options="header",width="50%"]
|===============
| Value | Bits
| MODE  | 5 (= 0x17)
| _R_   | 8
| _G_   | 8
| _B_   | 8
| _A_   | 8
| ETC1D | 1
| ETC1I | 3
| ETC1S | 2
| ETC1R | 5
| ETC1G | 5
| ETC1B | 5
|===============

If ETC1D is 0, indicating that the corresponding ETC1 block encoding
would use individual rather than differential blocks, the unused top
bit of each of ETC1R, ETC1G, and ETC1B should be set to 0.

<<<

=== Interpolated blocks

Interpolated blocks have different layouts depending on the _Mode Index_.

==== Configuration

The assignment of bits to configuration values in each blockmode is shown
in <<uastc-block-configuration>>.
For table values read top to bottom, the corresponding number of bits
are stored consecutively in the block, starting with the least-significant
bit.

[[uastc-block-configuration]]
.Block configuration bits
[options="header",width="50%",cols="3,2,1"]
|===============
| _Mode Index_    | Value    | Bits
| 0..7, 9..18     | MODE     | 2-7
| 0..7, 9..18     | BC1H0    | 1
| 0..7, 9, 13..18 | BC1H1    | 1
| 0..7, 9..18     | ETC1F    | 1
| 0..7, 9..18     | ETC1D    | 1
| 0..7, 9..18     | ETCI0    | 3
| 0..7, 9..18     | ETCI1    | 3
| 0..9, 13..18    | ETCBI    | 5
| 9..17           | ETC2T    | 4
| 9..17           | ETC2M    | 4
| 3               | PAT      | 4
| 2, 4, 7, 9, 16  | PAT      | 5
| 6, 11, 13       | CSEL     | 2
|===============

==== Endpoint bits

The bits which encode endpoints immediately follow the configuration bits.

===== _num_ebits_

The number of bits, _num_ebits_, used to encode endpoints depends on the
decoded _Mode Index_ value as shown in <<uastc-endpoint-bits>>.

[[uastc-endpoint-bits]]
.Endpoint bits for each mode
[width="65%",cols="5,18*1"]
|===============
| _Mode Index_ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18
| _num_ebits_  | 6 | 8 | 4 | 2 | 3 | 8 | 5 | 3 | 4 |  4 |  4 |  6 |  8 |  8 |  8 |  8 |  8 |  5
|===============

<<<

===== Endpoint encoding

The assignment of bits to endpoint values in each block mode is shown
in <<uastc-block-endpoints-1>> and <<uastc-block-endpoints-2>>.
For table values read top to bottom, the corresponding number of bits
are stored consecutively in the block, starting with the least-significant
bit after the configuration bits.

[[uastc-block-endpoints-1]]
.Block endpoint description prefix
[options="header",width="90%",cols="30,20,20,1,30,20,20,1,30,20,20,1,30,20,20"]
|===============
| _Mode Index_ | Value | Bits  | | _Mode Index_ | Value | Bits  | | _Mode Index_ | Value | Bits  | | _Mode Index_ | Value | Bits
| 4, 6, 7      | EQ[0] | 7 1.4+| | 0            | ET[0] | 8 1.4+| | 3            | ET[0] | 8 1.4+| | 10..12       | ET[0] | 8
| 4, 6, 7      | EQ[1] | 7       | 0            | ET[1] | 2       | 3            | ET[1] | 8       | 10..12       | ET[1] | 5
| 4, 7         | EQ[2] | 7   3.2+|                                | 3            | ET[2] | 8   3.2+|
| 4, 7         | EQ[3] | 7                                        | 3            | ET[3] | 5
|              |       |
|              |       |
|===============

[[uastc-block-endpoints-2]]
.Block endpoint description suffix
[options="header",width="80%",cols="30,20,20,1,30,20,20"]
|===============
| _Mode Index_    | Value | Bits       | | _Mode Index_ | Value | Bits
| 0..7, 9..14, 18 | _RL0_ | _num_ebits_ 1.22+| | 15..17 | _LL0_ | _num_ebits_
| 0..7, 9..14, 18 | _RH0_ | _num_ebits_ | 15..17 | _LH0_ | _num_ebits_
| 0..7, 9..14, 18 | _GL0_ | _num_ebits_ 1.4+| 1.4+|  1.4+|
| 0..7, 9..14, 18 | _GH0_ | _num_ebits_
| 0..7, 9..14, 18 | _BL0_ | _num_ebits_
| 0..7, 9..14, 18 | _BH0_ | _num_ebits_
| 9..14           | _AL0_ | _num_ebits_ | 15..17 | _AL0_ | _num_ebits_
| 9..14           | _AH0_ | _num_ebits_ | 15..17 | _AH0_ | _num_ebits_
| 2..4, 7, 9      | _RL1_ | _num_ebits_ | 16     | _LL1_ | _num_ebits_
| 2..4, 7, 9      | _RH1_ | _num_ebits_ | 16     | _LH1_ | _num_ebits_
| 2..4, 7, 9      | _GL1_ | _num_ebits_ 1.4+| 1.4+|  1.4+|
| 2..4, 7, 9      | _GH1_ | _num_ebits_
| 2..4, 7, 9      | _BL1_ | _num_ebits_
| 2..4, 7, 9      | _BH1_ | _num_ebits_
| 3               | _RL2_ | _num_ebits_ 1.6+| 1.6+|  1.6+|
| 3               | _RH2_ | _num_ebits_
| 3               | _GL2_ | _num_ebits_
| 3               | _GH2_ | _num_ebits_
| 3               | _BL2_ | _num_ebits_
| 3               | _BH2_ | _num_ebits_
| 9               | _AL1_ | _num_ebits_ | 16     | _AL1_ | _num_ebits_
| 9               | _AH1_ | _num_ebits_ | 16     | _AH1_ | _num_ebits_
|===============

<<<

==== Weights

Weight values are stored per texel, and indicate an interpolation
between the corresponding endpoints.
This section immediately follows the endpoint bits.
Weights are stored in raster order: increasing x order
most frequently, then increasing y order.

===== _num_wbits_

The value of _num_wbits_ depends on the _Mode Index_ as shown in <<uastc-weight-bits>>.

[[uastc-weight-bits]]
.UASTC weight bits for each mode
[width="65%",cols="5,18*1"]
|===============
| _Mode Index_ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18
| _num_wbits_  | 4 | 2 | 3 | 2 | 2 | 3 | 2 | 2 | 2 |  4 |  2 |  3 |  1 |  2 |  4 |  2 |  2 |  5
|===============

===== _anchor_indices_

As in the _index bits_ of <<bptc_bc7,BC7>>, one bit of the weight value of
one texel can be treated as implicit by swapping the weight values as
required.
The texel chosen is at the _anchor_index_ for the pattern.

When _Mode Index_ is 2, 4, 9, or 16, the value of _anchor_indices_ depends
on the value encoded in _PAT_ as shown in <<uastc-anchor-24916>>.

[[uastc-anchor-24916]]
.UASTC anchor indices for the first and second partition for _Mode Indices_ 2, 4, 9, and 16
[width="65%",cols="5,10*1"]
|===============
| _PAT_            |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~ |  ~8~ | ~9~
| _anchor_indices_ |  0,2 |  0,3 |  1,0 |  0,3 |  7,0 |  0,2 |  3,0 |  7,0 | 0,11 | 2,0
| _PAT_            | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~ | ~16~ | ~17~ | ~18~ | ~19~
| _anchor_indices_ |  0,7 | 11,0 |  3,0 |  8,0 |  0,4 | 12,0 |  1,0 |  8,0 |  0,1 | 0,2
| _PAT_            | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~
| _anchor_indices_ |  0,4 |  8,0 |  1,0 |  0,2 |  4,0 |  0,1 |  4,0 |  1,0 |  4,0 |  1,0
|===============

When _Mode Index_ is 3, the value of _anchor_indices_ depends on the
value encoded in _PAT_ as shown in <<uastc-anchor-3>>.

[[uastc-anchor-3]]
.UASTC anchor indices for the first, second, and third partition for _Mode Index_ 3
[width="90%",cols="5,11*2"]
|===============
| _PAT_            |  ~0~   |  ~1~   |  ~2~   |  ~3~  |  ~4~  |  ~5~  |  ~6~  |  ~7~  |  ~8~  |  ~9~  | ~10~
| _anchor_indices_ | 0,8,10 | 8,0,12 | 4,0,12 | 8,0,4 | 3,0,2 | 0,1,3 | 0,2,1 | 1,9,0 | 1,2,0 | 4,0,8 | 0,6,2
|===============

<<<

When _Mode Index_ is 7, the value of _anchor_indices_ depends on the
value encoded in _PAT_ as shown in <<uastc-anchor-7>>.

[[uastc-anchor-7]]
.UASTC anchor indices for the first and second partition for _Mode Index_ 7
[width="65%",cols="5,10*1"]
|===============
| _PAT_            |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~ |  ~8~ | ~9~
| _anchor_indices_ |  0,4 |  0,2 |  2,0 |  0,7 |  8,0 |  0,1 |  0,3 |  0,1 |  2,0 | 0,1
| _PAT_            | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~ | ~16~ | ~17~ | ~18~ |
| _anchor_indices_ |  0,8 |  2,0 |  0,1 |  0,7 | 12,0 |  2,0 |  9,0 |  0,2 |  4,0 |
|===============

Note that the _anchor_indices_ correspond to the first texel of each partition
in raster order.
The texels corresponding to _anchor_indices_ are highlit in
<<uastc-subsets-mode7>>, <<uastc-subsets-mode24916>> and <<uastc-subsets-mode3>>.

If the value encoded in _PAT_ is greater than the maximum value listed in
the corresponding tables for these formats, no further processing is performed
and the block must be decoded to the error color (255, 0, 255, 255).

In other modes, the (single) _anchor index_ is always 0.

===== Weight encoding

The assignment of bits to weight values in each block mode is shown
in <<uastc-block-weights>>.
For table values read top to bottom, the corresponding number of bits
are stored consecutively in the block, starting with the least-significant
bit after the configuration bits.

[[uastc-block-weights]]
.UASTC weight bit assignment
[width="75%",cols="3,3,2,2"]
|===============
2+<| for (i = 0; i < 16; i++) { | Value       | Bits
1.4+|  | _Mode Index_ {isin} 0-7, 9-18 +
i {isin} _anchor_indices_    | WEIGHTS0[i] | _num_wbits_ - 1
| _Mode Index_ {isin} 6,11,13,17 +
i {isin} _anchor_indices_  | WEIGHTS1[i] | _num_wbits_ - 1
| _Mode Index_ {isin} 0-7, 9-18 +
i {notin} _anchor_indices_   | WEIGHTS0[i] | _num_wbits_
| _Mode Index_ {isin} 6,11,13,17 +
i {notin} _anchor_indices_ | WEIGHTS1[i] | _num_wbits_
4+<| }
|===============

<<<

=== UASTC mode encoding summary (informative)

A summary of the bit allocations in each UASTC mode can be found in
<<uastc-modesummary-1>> through <<uastc-modesummary-6>>.
Most mode encodings are followed by weight values of an indicated number
of bits per texel, the arrangement of which may depend on the _PAT_ field.
Dual-plane modes are indicated by ``{times}2'' in the weight description.
Note that one bit per partition is reclaimed from the weights according
to the _anchor_indices_.
Any unassigned bits (following the weights, if present) are set to 0.

[[uastc-modesummary-1]]
.UASTC mode encoding bits 0..33 (1/2)
[cols="2,10*3"]
|===========
| _Mode Index_ |        11 |       10 |       12 |        0 |       18 |        3 |        7 |        5 |       14 |        9
|  0 |         0 |        0 |        0 |        1 |        1 |        1 |        1 |        1 |        1 |        1
|  1 |         0 |        1 |        1 |        0 |        0 |        1 |        1 |        1 |        0 |        1
|  2 |     BC1H0 |        0 |        1 |        0 |        0 |        0 |        1 |        0 |        1 |        1
|  3 |     ETC1F |    BC1H0 |    BC1H0 |        0 |        1 |        0 |        0 |        1 |        1 |        1
|  4 |     ETC1D |    ETC1F |    ETC1F |    BC1H0 |    BC1H0 |        0 |        0 |        0 |        0 |        0
|  5 |  ETCI0^0^ |    ETC1D |    ETC1D |    BC1H1 |    BC1H1 |    BC1H0 |    BC1H0 |    BC1H0 |    BC1H0 |    BC1H0
|  6 |  ETCI0^1^ | ETCI0^0^ | ETCI0^0^ |    ETC1F |    ETC1F |    BC1H1 |    BC1H1 |    BC1H1 |    BC1H1 |    BC1H1
|  7 |  ETCI0^2^ | ETCI0^1^ | ETCI0^1^ |    ETC1D |    ETC1D |    ETC1F |    ETC1F |    ETC1F |    ETC1F |    ETC1F
|  8 |  ETCI1^0^ | ETCI0^2^ | ETCI0^2^ | ETCI0^0^ | ETCI0^0^ |    ETC1D |    ETC1D |    ETC1D |    ETC1D |    ETC1D
|  9 |  ETCI1^1^ | ETCI1^0^ | ETCI1^0^ | ETCI0^1^ | ETCI0^1^ | ETCI0^0^ | ETCI0^0^ | ETCI0^0^ | ETCI0^0^ | ETCI0^0^
| 10 |  ETCI1^2^ | ETCI1^1^ | ETCI1^1^ | ETCI0^2^ | ETCI0^2^ | ETCI0^1^ | ETCI0^1^ | ETCI0^1^ | ETCI0^1^ | ETCI0^1^
| 11 |  ETC2T^0^ | ETCI1^2^ | ETCI1^2^ | ETCI1^0^ | ETCI1^0^ | ETCI0^2^ | ETCI0^2^ | ETCI0^2^ | ETCI0^2^ | ETCI0^2^
| 12 |  ETC2T^1^ | ETC2T^0^ | ETC2T^0^ | ETCI1^1^ | ETCI1^1^ | ETCI1^0^ | ETCI1^0^ | ETCI1^0^ | ETCI1^0^ | ETCI1^0^
| 13 |  ETC2T^2^ | ETC2T^1^ | ETC2T^1^ | ETCI1^2^ | ETCI1^2^ | ETCI1^1^ | ETCI1^1^ | ETCI1^1^ | ETCI1^1^ | ETCI1^1^
| 14 |  ETC2T^3^ | ETC2T^2^ | ETC2T^2^ | ETCBI^0^ | ETCBI^0^ | ETCI1^2^ | ETCI1^2^ | ETCI1^2^ | ETCI1^2^ | ETCI1^2^
| 15 |  ETC2M^0^ | ETC2T^3^ | ETC2T^3^ | ETCBI^1^ | ETCBI^1^ | ETCBI^0^ | ETCBI^0^ | ETCBI^0^ | ETCBI^0^ | ETCBI^0^
| 16 |  ETC2M^1^ | ETC2M^0^ | ETC2M^0^ | ETCBI^2^ | ETCBI^2^ | ETCBI^1^ | ETCBI^1^ | ETCBI^1^ | ETCBI^1^ | ETCBI^1^
| 17 |  ETC2M^2^ | ETC2M^1^ | ETC2M^1^ | ETCBI^3^ | ETCBI^3^ | ETCBI^2^ | ETCBI^2^ | ETCBI^2^ | ETCBI^2^ | ETCBI^2^
| 18 |  ETC2M^3^ | ETC2M^2^ | ETC2M^2^ | ETCBI^4^ | ETCBI^4^ | ETCBI^3^ | ETCBI^3^ | ETCBI^3^ | ETCBI^3^ | ETCBI^3^
| 19 |   CSEL^0^ | ETC2M^3^ | ETC2M^3^ | ET\[0]^0^ | _RL0^0^_ | ETCBI^4^ | ETCBI^4^ | ETCBI^4^ | ETCBI^4^ | ETCBI^4^
| 20 |   CSEL^1^ | ET\[0]^0^ | ET\[0]^0^ | ET\[0]^1^ | _RL0^1^_ |   PAT^0^ |   PAT^0^ | _RL0^0^_ | ETC2T^0^ | ETC2T^0^
| 21 |  ET\[0]^0^ | ET\[0]^1^ | ET\[0]^1^ | ET\[0]^2^ | _RL0^2^_ |   PAT^1^ |   PAT^1^ | _RL0^1^_ | ETC2T^1^ | ETC2T^1^
| 22 |  ET\[0]^1^ | ET\[0]^2^ | ET\[0]^2^ | ET\[0]^3^ | _RL0^3^_ |   PAT^2^ |   PAT^2^ | _RL0^2^_ | ETC2T^2^ | ETC2T^2^
| 23 |  ET\[0]^2^ | ET\[0]^3^ | ET\[0]^3^ | ET\[0]^4^ | _RL0^4^_ |   PAT^3^ |   PAT^3^ | _RL0^3^_ | ETC2T^3^ | ETC2T^3^
| 24 |  ET\[0]^3^ | ET\[0]^4^ | ET\[0]^4^ | ET\[0]^5^ | _RH0^0^_ | ET\[0]^0^ |   PAT^4^ | _RL0^4^_ | ETC2M^0^ | ETC2M^0^
| 25 |  ET\[0]^4^ | ET\[0]^5^ | ET\[0]^5^ | ET\[0]^6^ | _RH0^1^_ | ET\[0]^1^ | EQ\[0]^0^ | _RL0^5^_ | ETC2M^1^ | ETC2M^1^
| 26 |  ET\[0]^5^ | ET\[0]^6^ | ET\[0]^6^ | ET\[0]^7^ | _RH0^2^_ | ET\[0]^2^ | EQ\[0]^1^ | _RL0^6^_ | ETC2M^2^ | ETC2M^2^
| 27 |  ET\[0]^6^ | ET\[0]^7^ | ET\[0]^7^ | ET\[1]^0^ | _RH0^3^_ | ET\[0]^3^ | EQ\[0]^2^ | _RL0^7^_ | ETC2M^3^ | ETC2M^3^
| 28 |  ET\[0]^7^ | ET\[1]^0^ | ET\[1]^0^ | ET\[1]^1^ | _RH0^4^_ | ET\[0]^4^ | EQ\[0]^3^ | _RH0^0^_ | _RL0^0^_ |   PAT^0^
| 29 |  ET\[1]^0^ | ET\[1]^1^ | ET\[1]^1^ | _RL0^0^_ | _GL0^0^_ | ET\[0]^5^ | EQ\[0]^4^ | _RH0^1^_ | _RL0^1^_ |   PAT^1^
| 30 |  ET\[1]^1^ | ET\[1]^2^ | ET\[1]^2^ | _RL0^1^_ | _GL0^1^_ | ET\[0]^6^ | EQ\[0]^5^ | _RH0^2^_ | _RL0^2^_ |   PAT^2^
| 31 |  ET\[1]^2^ | ET\[1]^3^ | ET\[1]^3^ | _RL0^2^_ | _GL0^2^_ | ET\[0]^7^ | EQ\[0]^6^ | _RH0^3^_ | _RL0^3^_ |   PAT^3^
| 32 |  ET\[1]^3^ | ET\[1]^4^ | ET\[1]^4^ | _RL0^3^_ | _GL0^3^_ | ET\[1]^0^ | EQ\[1]^0^ | _RH0^4^_ | _RL0^4^_ |   PAT^4^
| 33 |  ET\[1]^4^ | _RL0^0^_ | _RL0^0^_ | _RL0^4^_ | _GL0^4^_ | ET\[1]^1^ | EQ\[1]^1^ | _RH0^5^_ | _RL0^5^_ | _RL0^0^_
|===========

<<<

[[uastc-modesummary-2]]
.UASTC mode encoding bits 34..67 (1/2)
[cols="2,10*3"]
|===========
| _Mode Index_ |        11 |       10 |       12 |        0 |       18 |        3 |        7 |        5 |       14 |        9
| 34 |  _RL0^0^_ | _RL0^1^_ | _RL0^1^_ | _RL0^5^_ | _GH0^0^_ | ET\[1]^2^ | EQ\[1]^2^ | _RH0^6^_ | _RL0^6^_ | _RL0^1^_
| 35 |  _RL0^1^_ | _RL0^2^_ | _RL0^2^_ | _RH0^0^_ | _GH0^1^_ | ET\[1]^3^ | EQ\[1]^3^ | _RH0^7^_ | _RL0^7^_ | _RL0^2^_
| 36 |  _RL0^2^_ | _RL0^3^_ | _RL0^3^_ | _RH0^1^_ | _GH0^2^_ | ET\[1]^4^ | EQ\[1]^4^ | _GL0^0^_ | _RH0^0^_ | _RL0^3^_
| 37 |  _RL0^3^_ | _RH0^0^_ | _RL0^4^_ | _RH0^2^_ | _GH0^3^_ | ET\[1]^5^ | EQ\[1]^5^ | _GL0^1^_ | _RH0^1^_ | _RH0^0^_
| 38 |  _RH0^0^_ | _RH0^1^_ | _RL0^5^_ | _RH0^3^_ | _GH0^4^_ | ET\[1]^6^ | EQ\[1]^6^ | _GL0^2^_ | _RH0^2^_ | _RH0^1^_
| 39 |  _RH0^1^_ | _RH0^2^_ | _RH0^0^_ | _RH0^4^_ | _BL0^0^_ | ET\[1]^7^ | EQ\[2]^0^ | _GL0^3^_ | _RH0^3^_ | _RH0^2^_
| 40 |  _RH0^2^_ | _RH0^3^_ | _RH0^1^_ | _RH0^5^_ | _BL0^1^_ | ET\[2]^0^ | EQ\[2]^1^ | _GL0^4^_ | _RH0^4^_ | _RH0^3^_
| 41 |  _RH0^3^_ | _GL0^0^_ | _RH0^2^_ | _GL0^0^_ | _BL0^2^_ | ET\[2]^1^ | EQ\[2]^2^ | _GL0^5^_ | _RH0^5^_ | _GL0^0^_
| 42 |  _GL0^0^_ | _GL0^1^_ | _RH0^3^_ | _GL0^1^_ | _BL0^3^_ | ET\[2]^2^ | EQ\[2]^3^ | _GL0^6^_ | _RH0^6^_ | _GL0^1^_
| 43 |  _GL0^1^_ | _GL0^2^_ | _RH0^4^_ | _GL0^2^_ | _BL0^4^_ | ET\[2]^3^ | EQ\[2]^4^ | _GL0^7^_ | _RH0^7^_ | _GL0^2^_
| 44 |  _GL0^2^_ | _GL0^3^_ | _RH0^5^_ | _GL0^3^_ | _BH0^0^_ | ET\[2]^4^ | EQ\[2]^5^ | _GH0^0^_ | _GL0^0^_ | _GL0^3^_
| 45 |  _GL0^3^_ | _GH0^0^_ | _GL0^0^_ | _GL0^4^_ | _BH0^1^_ | ET\[2]^5^ | EQ\[2]^6^ | _GH0^1^_ | _GL0^1^_ | _GH0^0^_
| 46 |  _GH0^0^_ | _GH0^1^_ | _GL0^1^_ | _GL0^5^_ | _BH0^2^_ | ET\[2]^6^ | EQ\[3]^0^ | _GH0^2^_ | _GL0^2^_ | _GH0^1^_
| 47 |  _GH0^1^_ | _GH0^2^_ | _GL0^2^_ | _GH0^0^_ | _BH0^3^_ | ET\[2]^7^ | EQ\[3]^1^ | _GH0^3^_ | _GL0^3^_ | _GH0^2^_
| 48 |  _GH0^2^_ | _GH0^3^_ | _GL0^3^_ | _GH0^1^_ | _BH0^4^_ | ET\[3]^0^ | EQ\[3]^2^ | _GH0^4^_ | _GL0^4^_ | _GH0^3^_
| 49 |  _GH0^3^_ | _BL0^0^_ | _GL0^4^_ | _GH0^2^_ | Wt^0..4^ | ET\[3]^1^ | EQ\[3]^3^ | _GH0^5^_ | _GL0^5^_ | _BL0^0^_
| 50 |  _BL0^0^_ | _BL0^1^_ | _GL0^5^_ | _GH0^3^_ |    :     | ET\[3]^2^ | EQ\[3]^4^ | _GH0^6^_ | _GL0^6^_ | _BL0^1^_
| 51 |  _BL0^1^_ | _BL0^2^_ | _GH0^0^_ | _GH0^4^_ |          | ET\[3]^3^ | EQ\[3]^5^ | _GH0^7^_ | _GL0^7^_ | _BL0^2^_
| 52 |  _BL0^2^_ | _BL0^3^_ | _GH0^1^_ | _GH0^5^_ |          | ET\[3]^4^ | EQ\[3]^6^ | _BL0^0^_ | _GH0^0^_ | _BL0^3^_
| 53 |  _BL0^3^_ | _BH0^0^_ | _GH0^2^_ | _BL0^0^_ |          | _RL0^0^_ | _RL0^0^_ | _BL0^1^_ | _GH0^1^_ | _BH0^0^_
| 54 |  _BH0^0^_ | _BH0^1^_ | _GH0^3^_ | _BL0^1^_ |          | _RL0^1^_ | _RL0^1^_ | _BL0^2^_ | _GH0^2^_ | _BH0^1^_
| 55 |  _BH0^1^_ | _BH0^2^_ | _GH0^4^_ | _BL0^2^_ |          | _RH0^0^_ | _RL0^2^_ | _BL0^3^_ | _GH0^3^_ | _BH0^2^_
| 56 |  _BH0^2^_ | _BH0^3^_ | _GH0^5^_ | _BL0^3^_ |          | _RH0^1^_ | _RH0^0^_ | _BL0^4^_ | _GH0^4^_ | _BH0^3^_
| 57 |  _BH0^3^_ | _AL0^0^_ | _BL0^0^_ | _BL0^4^_ |          | _GL0^0^_ | _RH0^1^_ | _BL0^5^_ | _GH0^5^_ | _AL0^0^_
| 58 |  _AL0^0^_ | _AL0^1^_ | _BL0^1^_ | _BL0^5^_ |          | _GL0^1^_ | _RH0^2^_ | _BL0^6^_ | _GH0^6^_ | _AL0^1^_
| 59 |  _AL0^1^_ | _AL0^2^_ | _BL0^2^_ | _BH0^0^_ |          | _GH0^0^_ | _GL0^0^_ | _BL0^7^_ | _GH0^7^_ | _AL0^2^_
| 60 |  _AL0^2^_ | _AL0^3^_ | _BL0^3^_ | _BH0^1^_ |          | _GH0^1^_ | _GL0^1^_ | _BH0^0^_ | _BL0^0^_ | _AL0^3^_
| 61 |  _AL0^3^_ | _AH0^0^_ | _BL0^4^_ | _BH0^2^_ |          | _BL0^0^_ | _GL0^2^_ | _BH0^1^_ | _BL0^1^_ | _AH0^0^_
| 62 |  _AH0^0^_ | _AH0^1^_ | _BL0^5^_ | _BH0^3^_ |          | _BL0^1^_ | _GH0^0^_ | _BH0^2^_ | _BL0^2^_ | _AH0^1^_
| 63 |  _AH0^1^_ | _AH0^2^_ | _BH0^0^_ | _BH0^4^_ |          | _BH0^0^_ | _GH0^1^_ | _BH0^3^_ | _BL0^3^_ | _AH0^2^_
| 64 |  _AH0^2^_ | _AH0^3^_ | _BH0^1^_ | _BH0^5^_ |          | _BH0^1^_ | _GH0^2^_ | _BH0^4^_ | _BL0^4^_ | _AH0^3^_
| 65 |  _AH0^3^_ | Wt^0..3^ | _BH0^2^_ | Wt^0..3^ |          | _RL1^0^_ | _BL0^0^_ | _BH0^5^_ | _BL0^5^_ | _RL1^0^_
| 66 | Wt^0..1^{times}2 | : | _BH0^3^_ |     :    |          | _RL1^1^_ | _BL0^1^_ | _BH0^6^_ | _BL0^6^_ | _RL1^1^_
| 67 |     :     |          | _BH0^4^_ |          |          | _RH1^0^_ | _BL0^2^_ | _BH0^7^_ | _BL0^7^_ | _RL1^2^_
|===========

<<<

[[uastc-modesummary-3]]
.UASTC mode encoding bits 68..98 (1/2)
[cols="2,10*3"]
|===========
| _Mode Index_ |        11 |       10 |       12 |        0 |       18 |        3 |        7 |        5 |       14 |        9
| 68 |           |          | _BH0^5^_ |          |          | _RH1^1^_ | _BH0^0^_ | Wt^0..2^ | _BH0^0^_ | _RL1^3^_
| 69 |           |          | _AL0^0^_ |          |          | _GL1^0^_ | _BH0^1^_ |          | _BH0^1^_ | _RH1^0^_
| 70 |           |          | _AL0^1^_ |          |          | _GL1^1^_ | _BH0^2^_ |          | _BH0^2^_ | _RH1^1^_
| 71 |           |          | _AL0^2^_ |          |          | _GH1^0^_ | _RL1^0^_ |          | _BH0^3^_ | _RH1^2^_
| 72 |           |          | _AL0^3^_ |          |          | _GH1^1^_ | _RL1^1^_ |          | _BH0^4^_ | _RH1^3^_
| 73 |           |          | _AL0^4^_ |          |          | _BL1^0^_ | _RL1^2^_ |          | _BH0^5^_ | _GL1^0^_
| 74 |           |          | _AL0^5^_ |          |          | _BL1^1^_ | _RH1^0^_ |          | _BH0^6^_ | _GL1^1^_
| 75 |           |          | _AH0^0^_ |          |          | _BH1^0^_ | _RH1^1^_ |          | _BH0^7^_ | _GL1^2^_
| 76 |           |          | _AH0^1^_ |          |          | _BH1^1^_ | _RH1^2^_ |          | _AL0^0^_ | _GL1^3^_
| 77 |           |          | _AH0^2^_ |          |          | _RL2^0^_ | _GL1^0^_ |          | _AL0^1^_ | _GH1^0^_
| 78 |           |          | _AH0^3^_ |          |          | _RL2^1^_ | _GL1^1^_ |          | _AL0^2^_ | _GH1^1^_
| 79 |           |          | _AH0^4^_ |          |          | _RH2^0^_ | _GL1^2^_ |          | _AL0^3^_ | _GH1^2^_
| 80 |           |          | _AH0^5^_ |          |          | _RH2^1^_ | _GH1^0^_ |          | _AL0^4^_ | _GH1^3^_
| 81 |           |          | Wt^0..2^ |          |          | _GL2^0^_ | _GH1^1^_ |          | _AL0^5^_ | _BL1^0^_
| 82 |           |          |    :     |          |          | _GL2^1^_ | _GH1^2^_ |          | _AL0^6^_ | _BL1^1^_
| 83 |           |          |          |          |          | _GH2^0^_ | _BL1^0^_ |          | _AL0^7^_ | _BL1^2^_
| 84 |           |          |          |          |          | _GH2^1^_ | _BL1^1^_ |          | _AH0^0^_ | _BL1^3^_
| 85 |           |          |          |          |          | _BL2^0^_ | _BL1^2^_ |          | _AH0^1^_ | _BH1^0^_
| 86 |           |          |          |          |          | _BL2^1^_ | _BH1^0^_ |          | _AH0^2^_ | _BH1^1^_
| 87 |           |          |          |          |          | _BH2^0^_ | _BH1^1^_ |          | _AH0^3^_ | _BH1^2^_
| 88 |           |          |          |          |          | _BH2^1^_ | _BH1^2^_ |          | _AH0^4^_ | _BH1^3^_
| 89 |           |          |          |          |          | Wt^0..1^ | Wt^0..1^ |          | _AH0^5^_ | _AL1^0^_
| 90 |           |          |          |          |          |     :    |     :    |          | _AH0^6^_ | _AL1^1^_
| 91 |           |          |          |          |          |          |          |          | _AH0^7^_ | _AL1^2^_
| 92 |           |          |          |          |          |          |          |          | Wt^0..1^ | _AL1^3^_
| 93 |           |          |          |          |          |          |          |          |     :    | _AH1^0^_
| 94 |           |          |          |          |          |          |          |          |          | _AH1^1^_
| 95 |           |          |          |          |          |          |          |          |          | _AH1^2^_
| 96 |           |          |          |          |          |          |          |          |          | _AH1^3^_
| 97 |           |          |          |          |          |          |          |          |          | Wt^0..1^
| 98 |           |          |          |          |          |          |          |          |          |     :
|===========

<<<

[[uastc-modesummary-4]]
.UASTC mode encoding bits 0..33 (2/2)
[cols="2,10*3"]
|===========
| _Mode Index_ |        4 |        8 |        6 |        2 |       13 |       16 |       17 |        1 |       15 |       19
|  0 |        1 |        1 |        1 |        1 |        1 |        1 |        1 |        1 |        1 |        1
|  1 |        1 |        1 |        1 |        0 |        1 |        0 |        0 |        0 |        0 |        0
|  2 |        0 |        1 |        0 |        1 |        1 |        1 |        1 |        1 |        1 |        1
|  3 |        0 |        0 |        1 |        1 |        1 |        0 |        0 |        0 |        0 |        0
|  4 |        1 |        1 |        1 |        1 |        1 |        1 |        0 |        1 |        0 |        0
|  5 |    BC1H0 |   _R^0^_ |    BC1H0 |    BC1H0 |    BC1H0 |        0 |        1 |        1 |        0 |        0
|  6 |    BC1H1 |   _R^1^_ |    BC1H1 |    BC1H1 |    BC1H1 |    BC1H0 |    BC1H0 |    BC1H0 |        0 |        1
|  7 |    ETC1F |   _R^2^_ |    ETC1F |    ETC1F |    ETC1F |    BC1H1 |    BC1H1 |    BC1H1 |    BC1H0 |
|  8 |    ETC1D |   _R^3^_ |    ETC1D |    ETC1D |    ETC1D |    ETC1F |    ETC1F |    ETC1F |    BC1H1 |
|  9 | ETCI0^0^ |   _R^4^_ | ETCI0^0^ | ETCI0^0^ | ETCI0^0^ |    ETC1D |    ETC1D |    ETC1D |    ETC1F |
| 10 | ETCI0^1^ |   _R^5^_ | ETCI0^1^ | ETCI0^1^ | ETCI0^1^ | ETCI0^0^ | ETCI0^0^ | ETCI0^0^ |    ETC1D |
| 11 | ETCI0^2^ |   _R^6^_ | ETCI0^2^ | ETCI0^2^ | ETCI0^2^ | ETCI0^1^ | ETCI0^1^ | ETCI0^1^ | ETCI0^0^ |
| 12 | ETCI1^0^ |   _R^7^_ | ETCI1^0^ | ETCI1^0^ | ETCI1^0^ | ETCI0^2^ | ETCI0^2^ | ETCI0^2^ | ETCI0^1^ |
| 13 | ETCI1^1^ |   _G^0^_ | ETCI1^1^ | ETCI1^1^ | ETCI1^1^ | ETCI1^0^ | ETCI1^0^ | ETCI1^0^ | ETCI0^2^ |
| 14 | ETCI1^2^ |   _G^1^_ | ETCI1^2^ | ETCI1^2^ | ETCI1^2^ | ETCI1^1^ | ETCI1^1^ | ETCI1^1^ | ETCI1^0^ |
| 15 | ETCBI^0^ |   _G^2^_ | ETCBI^0^ | ETCBI^0^ | ETCBI^0^ | ETCI1^2^ | ETCI1^2^ | ETCI1^2^ | ETCI1^1^ |
| 16 | ETCBI^1^ |   _G^3^_ | ETCBI^1^ | ETCBI^1^ | ETCBI^1^ | ETCBI^0^ | ETCBI^0^ | ETCBI^0^ | ETCI1^2^ |
| 17 | ETCBI^2^ |   _G^4^_ | ETCBI^2^ | ETCBI^2^ | ETCBI^2^ | ETCBI^1^ | ETCBI^1^ | ETCBI^1^ | ETCBI^0^ |
| 18 | ETCBI^3^ |   _G^5^_ | ETCBI^3^ | ETCBI^3^ | ETCBI^3^ | ETCBI^2^ | ETCBI^2^ | ETCBI^2^ | ETCBI^1^ |
| 19 | ETCBI^4^ |   _G^6^_ | ETCBI^4^ | ETCBI^4^ | ETCBI^4^ | ETCBI^3^ | ETCBI^3^ | ETCBI^3^ | ETCBI^2^ |
| 20 |   PAT^0^ |   _G^7^_ |  CSEL^0^ |   PAT^0^ | ETC2T^0^ | ETCBI^4^ | ETCBI^4^ | ETCBI^4^ | ETCBI^3^ |
| 21 |   PAT^1^ |   _B^0^_ |  CSEL^1^ |   PAT^1^ | ETC2T^1^ | ETC2T^0^ | ETC2T^0^ | _RL0^0^_ | ETCBI^4^ |
| 22 |   PAT^2^ |   _B^1^_ | EQ\[0]^0^ |   PAT^2^ | ETC2T^2^ | ETC2T^1^ | ETC2T^1^ | _RL0^1^_ | ETC2T^0^ |
| 23 |   PAT^3^ |   _B^2^_ | EQ\[0]^1^ |   PAT^3^ | ETC2T^3^ | ETC2T^2^ | ETC2T^2^ | _RL0^2^_ | ETC2T^1^ |
| 24 |   PAT^4^ |   _B^3^_ | EQ\[0]^2^ |   PAT^4^ | ETC2M^0^ | ETC2T^3^ | ETC2T^3^ | _RL0^3^_ | ETC2T^2^ |
| 25 | EQ\[0]^0^ |   _B^4^_ | EQ\[0]^3^ | _RL0^0^_ | ETC2M^1^ | ETC2M^0^ | ETC2M^0^ | _RL0^4^_ | ETC2T^3^ |
| 26 | EQ\[0]^1^ |   _B^5^_ | EQ\[0]^4^ | _RL0^1^_ | ETC2M^2^ | ETC2M^1^ | ETC2M^1^ | _RL0^5^_ | ETC2M^0^ |
| 27 | EQ\[0]^2^ |   _B^6^_ | EQ\[0]^5^ | _RL0^2^_ | ETC2M^3^ | ETC2M^2^ | ETC2M^2^ | _RL0^6^_ | ETC2M^1^ |
| 28 | EQ\[0]^3^ |   _B^7^_ | EQ\[0]^6^ | _RL0^3^_ |  CSEL^0^ | ETC2M^3^ | ETC2M^3^ | _RL0^7^_ | ETC2M^2^ |
| 29 | EQ\[0]^4^ |   _A^0^_ | EQ\[1]^0^ | _RH0^0^_ |  CSEL^1^ |   PAT^0^ | _LL0^0^_ | _RH0^0^_ | ETC2M^3^ |
| 30 | EQ\[0]^5^ |   _A^1^_ | EQ\[1]^1^ | _RH0^1^_ | _RL0^0^_ |   PAT^1^ | _LL0^1^_ | _RH0^1^_ | _LL0^0^_ |
| 31 | EQ\[0]^6^ |   _A^2^_ | EQ\[1]^2^ | _RH0^2^_ | _RL0^1^_ |   PAT^2^ | _LL0^2^_ | _RH0^2^_ | _LL0^1^_ |
| 32 | EQ\[1]^0^ |   _A^3^_ | EQ\[1]^3^ | _RH0^3^_ | _RL0^2^_ |   PAT^3^ | _LL0^3^_ | _RH0^3^_ | _LL0^2^_ |
| 33 | EQ\[1]^1^ |   _A^4^_ | EQ\[1]^4^ | _GL0^0^_ | _RL0^3^_ |   PAT^4^ | _LL0^4^_ | _RH0^4^_ | _LL0^3^_ |
|===========

<<<

[[uastc-modesummary-5]]
.UASTC mode encoding bits 34..68 (2/2)
[cols="2,10*3"]
|===========
| _Mode Index_ |        4 |        8 |        6 |        2 |       13 |       16 |       17 |        1 |       15 |       19
| 34 | EQ\[1]^2^ |     A^5^ | EQ\[1]^5^ | _GL0^1^_ | _RL0^4^_ | _LL0^0^_ | _LL0^5^_ | _RH0^5^_ | _LL0^4^_ |
| 35 | EQ\[1]^3^ |     A^6^ | EQ\[1]^6^ | _GL0^2^_ | _RL0^5^_ | _LL0^1^_ | _LL0^6^_ | _RH0^6^_ | _LL0^5^_ |
| 36 | EQ\[1]^4^ |     A^7^ | _RL0^0^_ | _GL0^3^_ | _RL0^6^_ | _LL0^2^_ | _LL0^7^_ | _RH0^7^_ | _LL0^6^_ |
| 37 | EQ\[1]^5^ |    ETC1D | _RL0^1^_ | _GH0^0^_ | _RL0^7^_ | _LL0^3^_ | _LH0^0^_ | _GL0^0^_ | _LL0^7^_ |
| 38 | EQ\[1]^6^ | ETC1I^0^ | _RL0^2^_ | _GH0^1^_ | _RH0^0^_ | _LL0^4^_ | _LH0^1^_ | _GL0^1^_ | _LH0^0^_ |
| 39 | EQ\[2]^0^ | ETC1I^1^ | _RL0^3^_ | _GH0^2^_ | _RH0^1^_ | _LL0^5^_ | _LH0^2^_ | _GL0^2^_ | _LH0^1^_ |
| 40 | EQ\[2]^1^ | ETC1I^2^ | _RL0^4^_ | _GH0^3^_ | _RH0^2^_ | _LL0^6^_ | _LH0^3^_ | _GL0^3^_ | _LH0^2^_ |
| 41 | EQ\[2]^2^ | ETC1S^0^ | _RH0^0^_ | _BL0^0^_ | _RH0^3^_ | _LL0^7^_ | _LH0^4^_ | _GL0^4^_ | _LH0^3^_ |
| 42 | EQ\[2]^3^ | ETC1S^1^ | _RH0^1^_ | _BL0^1^_ | _RH0^4^_ | _LH0^0^_ | _LH0^5^_ | _GL0^5^_ | _LH0^4^_ |
| 43 | EQ\[2]^4^ | ETC1R^0^ | _RH0^2^_ | _BL0^2^_ | _RH0^5^_ | _LH0^1^_ | _LH0^6^_ | _GL0^6^_ | _LH0^5^_ |
| 44 | EQ\[2]^5^ | ETC1R^1^ | _RH0^3^_ | _BL0^3^_ | _RH0^6^_ | _LH0^2^_ | _LH0^7^_ | _GL0^7^_ | _LH0^6^_ |
| 45 | EQ\[2]^6^ | ETC1R^2^ | _RH0^4^_ | _BH0^0^_ | _RH0^7^_ | _LH0^3^_ | _AL0^0^_ | _GH0^0^_ | _LH0^7^_ |
| 46 | EQ\[3]^0^ | ETC1R^3^ | _GL0^0^_ | _BH0^1^_ | _GL0^0^_ | _LH0^4^_ | _AL0^1^_ | _GH0^1^_ | _AL0^0^_ |
| 47 | EQ\[3]^1^ | ETC1R^4^ | _GL0^1^_ | _BH0^2^_ | _GL0^1^_ | _LH0^5^_ | _AL0^2^_ | _GH0^2^_ | _AL0^1^_ |
| 48 | EQ\[3]^2^ | ETC1G^0^ | _GL0^2^_ | _BH0^3^_ | _GL0^2^_ | _LH0^6^_ | _AL0^3^_ | _GH0^3^_ | _AL0^2^_ |
| 49 | EQ\[3]^3^ | ETC1G^1^ | _GL0^3^_ | _RL1^0^_ | _GL0^3^_ | _LH0^7^_ | _AL0^4^_ | _GH0^4^_ | _AL0^3^_ |
| 50 | EQ\[3]^4^ | ETC1G^2^ | _GL0^4^_ | _RL1^1^_ | _GL0^4^_ | _AL0^0^_ | _AL0^5^_ | _GH0^5^_ | _AL0^4^_ |
| 51 | EQ\[3]^5^ | ETC1G^3^ | _GH0^0^_ | _RL1^2^_ | _GL0^5^_ | _AL0^1^_ | _AL0^6^_ | _GH0^6^_ | _AL0^5^_ |
| 52 | EQ\[3]^6^ | ETC1G^4^ | _GH0^1^_ | _RL1^3^_ | _GL0^6^_ | _AL0^2^_ | _AL0^7^_ | _GH0^7^_ | _AL0^6^_ |
| 53 | _RL0^0^_ | ETC1B^0^ | _GH0^2^_ | _RH1^0^_ | _GL0^7^_ | _AL0^3^_ | _AH0^0^_ | _BL0^0^_ | _AL0^7^_ |
| 54 | _RL0^1^_ | ETC1B^1^ | _GH0^3^_ | _RH1^1^_ | _GH0^0^_ | _AL0^4^_ | _AH0^1^_ | _BL0^1^_ | _AH0^0^_ |
| 55 | _RL0^2^_ | ETC1B^2^ | _GH0^4^_ | _RH1^2^_ | _GH0^1^_ | _AL0^5^_ | _AH0^2^_ | _BL0^2^_ | _AH0^1^_ |
| 56 | _RH0^0^_ | ETC1B^3^ | _BL0^0^_ | _RH1^3^_ | _GH0^2^_ | _AL0^6^_ | _AH0^3^_ | _BL0^3^_ | _AH0^2^_ |
| 57 | _RH0^1^_ | ETC1B^4^ | _BL0^1^_ | _GL1^0^_ | _GH0^3^_ | _AL0^7^_ | _AH0^4^_ | _BL0^4^_ | _AH0^3^_ |
| 58 | _RH0^2^_ |          | _BL0^2^_ | _GL1^1^_ | _GH0^4^_ | _AH0^0^_ | _AH0^5^_ | _BL0^5^_ | _AH0^4^_ |
| 59 | _GL0^0^_ |          | _BL0^3^_ | _GL1^2^_ | _GH0^5^_ | _AH0^1^_ | _AH0^6^_ | _BL0^6^_ | _AH0^5^_ |
| 60 | _GL0^1^_ |          | _BL0^4^_ | _GL1^3^_ | _GH0^6^_ | _AH0^2^_ | _AH0^7^_ | _BL0^7^_ | _AH0^6^_ |
| 61 | _GL0^2^_ |          | _BH0^0^_ | _GH1^0^_ | _GH0^7^_ | _AH0^3^_ | Wt^0..1^{times}2 | _BH0^0^_ | _AH0^7^_ |
| 62 | _GH0^0^_ |          | _BH0^1^_ | _GH1^1^_ | _BL0^0^_ | _AH0^4^_ |    :     | _BH0^1^_ | Wt^0..3^ |
| 63 | _GH0^1^_ |          | _BH0^2^_ | _GH1^2^_ | _BL0^1^_ | _AH0^5^_ |          | _BH0^2^_ |    :     |
| 64 | _GH0^2^_ |          | _BH0^3^_ | _GH1^3^_ | _BL0^2^_ | _AH0^6^_ |          | _BH0^3^_ |          |
| 65 | _BL0^0^_ |          | _BH0^4^_ | _BL1^0^_ | _BL0^3^_ | _AH0^7^_ |          | _BH0^4^_ |          |
| 66 | _BL0^1^_ |          | Wt^0..1^{times}2 | _BL1^1^_ | _BL0^4^_ | _LL1^0^_ |  | _BH0^5^_ |          |
| 67 | _BL0^2^_ |          |     :    | _BL1^2^_ | _BL0^5^_ | _LL1^1^_ |          | _BH0^6^_ |          |
| 68 | _BH0^0^_ |          |          | _BL1^3^_ | _BL0^6^_ | _LL1^2^_ |          | _BH0^7^_ |          |
|===========
<<<

[[uastc-modesummary-6]]
.UASTC mode encoding bits 69..99 (2/2)
[cols="2,10*3"]
|===========
| _Mode Index_ |        4 |        8 |        6 |        2 |       13 |       16 |       17 |        1 |       15 |       19
| 69 | _BH0^1^_ |          |          | _BH1^0^_ | _BL0^7^_ | _LL1^3^_ |          | Wt^0..1^ |          |
| 70 | _BH0^2^_ |          |          | _BH1^1^_ | _BH0^0^_ | _LL1^4^_ |          |    :     |          |
| 71 | _RL1^0^_ |          |          | _BH1^2^_ | _BH0^1^_ | _LL1^5^_ |          |          |          |
| 72 | _RL1^1^_ |          |          | _BH1^3^_ | _BH0^2^_ | _LL1^6^_ |          |          |          |
| 73 | _RL1^2^_ |          |          | Wt^0..2^ | _BH0^3^_ | _LL1^7^_ |          |          |          |
| 74 | _RH1^0^_ |          |          |    :     | _BH0^4^_ | _LH1^0^_ |          |          |          |
| 75 | _RH1^1^_ |          |          |          | _BH0^5^_ | _LH1^1^_ |          |          |          |
| 76 | _RH1^2^_ |          |          |          | _BH0^6^_ | _LH1^2^_ |          |          |          |
| 77 | _GL1^0^_ |          |          |          | _BH0^7^_ | _LH1^3^_ |          |          |          |
| 78 | _GL1^1^_ |          |          |          | _AL0^0^_ | _LH1^4^_ |          |          |          |
| 79 | _GL1^2^_ |          |          |          | _AL0^1^_ | _LH1^5^_ |          |          |          |
| 80 | _GH1^0^_ |          |          |          | _AL0^2^_ | _LH1^6^_ |          |          |          |
| 81 | _GH1^1^_ |          |          |          | _AL0^3^_ | _LH1^7^_ |          |          |          |
| 82 | _GH1^2^_ |          |          |          | _AL0^4^_ | _AL1^0^_ |          |          |          |
| 83 | _BL1^0^_ |          |          |          | _AL0^5^_ | _AL1^1^_ |          |          |          |
| 84 | _BL1^1^_ |          |          |          | _AL0^6^_ | _AL1^2^_ |          |          |          |
| 85 | _BL1^2^_ |          |          |          | _AL0^7^_ | _AL1^3^_ |          |          |          |
| 86 | _BH1^0^_ |          |          |          | _AH0^0^_ | _AL1^4^_ |          |          |          |
| 87 | _BH1^1^_ |          |          |          | _AH0^1^_ | _AL1^5^_ |          |          |          |
| 88 | _BH1^2^_ |          |          |          | _AH0^2^_ | _AL1^6^_ |          |          |          |
| 89 | Wt^0..1^ |          |          |          | _AH0^3^_ | _AL1^7^_ |          |          |          |
| 90 |    :     |          |          |          | _AH0^4^_ | _AH1^0^_ |          |          |          |
| 91 |          |          |          |          | _AH0^5^_ | _AH1^1^_ |          |          |          |
| 92 |          |          |          |          | _AH0^6^_ | _AH1^2^_ |          |          |          |
| 93 |          |          |          |          | _AH0^7^_ | _AH1^3^_ |          |          |          |
| 94 |          |          |          |          | Wt^0^{times}2 | _AH1^4^_ |     |          |          |
| 95 |          |          |          |          |     :    | _AH1^5^_ |          |          |          |
| 96 |          |          |          |          |          | _AH1^6^_ |          |          |          |
| 97 |          |          |          |          |          | _AH1^7^_ |          |          |          |
| 98 |          |          |          |          |          | Wt^0..1^ |          |          |          |
| 99 |          |          |          |          |          |    :     |          |          |          |
|===========

<<<

=== Decoding process

Decoding starts with parsing _Mode Index_ to determine whether the
block contains solid color (_Mode Index_ 8) or interpolated values.

==== Solid color blocks

8-bit values for *_R_*, *_G_*, *_B_*, and *_A_* are used for all 16 pixels
of the block.

==== Interpolated blocks

Decoding interpolated blocks involves several steps: extracting endpoints,
restoring interpolation weights, and interpolating pixel values.

===== Extracting endpoints

8-bit endpoint values are extracted and unquantized from encoded endpoint
bits (denoted as *_RL0_*, *_RH0_*, etc. in the bitstream) and packed *ET*
or *EQ* values (when present).

===== Unpacking Trits
When present, *ET* fields contain trit values for each
encoded endpoint packed in the same order as endpoints.
Trits (values of [0..2] range) are used when _Mode Index_ is 0, 3, 10, 11, or
12. Each *ET* value contains up to 5 trits packed as:

-----
ET = trit4 * 81 + trit3 * 27 + trit2 * 9 + trit1 * 3 + trit0
-----

When the number of endpoint values isn't a multiple of 5, the final *ET*
value contains fewer packed values.
For example, trits for _Mode Index_ 0 would be packed as:

-----
ET[0] = tritBL0 * 81 + tritGH0 * 27 + tritGL0 * 9 + tritRH0 * 3 + tritRL0
ET[1] = tritBH0
-----

Trit values could be unpacked by sequential modulus and division
operations or equivalent precomputed lookup tables:

-----
trit0 = ET % 3; trit1 = (ET % 9) / 3; trit2 = (ET % 27) / 9;
trit3 = (ET % 81) / 27; trit4 = (ET % 243) / 81;
-----

Implementations should be resilient to ET bytes containing
243..255, which are mapped to 0..12 by the above equations.

===== Unpacking Quints
When present, *EQ* fields contain quint values for each
encoded endpoint packed in the same order as endpoints.
Quints (values of [0..4] range) are used when _Mode Index_ is 4, 6, or 7.
Each *EQ* value contains 3 quints packed as:

-----
EQ = quint2 * 25 + quint1 * 5 + quint0
-----

Quint values could be unpacked by sequential modulus and division
operations or equivalent precomputed lookup tables:

-----
quint0 = EQ % 5; quint1 = (ET % 25) / 5; quint2 = (EQ % 125) / 25;
-----

Implementations should be resilient to EQ bit fields containing
125..127, which are mapped to 0..2 by the above equations.

[[uastc-unquantizing-endpoints]]
===== Unquantizing endpoints

Each endpoint value is defined by its trit/quint value (if present) and
remaining _num_ebits_ bits.
It must be unquantized to [0..255] range before being used for interpolation.

For modes that use only endpoint bits (i.e., their bitstream does not contain
*ET* or *EQ* fields, for example _Mode Index_ 18), unquantization is
performed by replicating endpoint bits from the most significant bit of the
value to the total length of 8.
For example, 5-bit ++abcde++ value must be dequantized to ++abcdeabc++ 8-bit
value.

Modes that use *ET* (trits) or *EQ* (quints) must be unquantized using
one of the following approaches:

* Using <<astc-endpoint-unquantization,ASTC Endpoint Unquantization>>.
  UASTC _Mode Indices_ map to ASTC ranges as defined by
  <<uastc-endpoint-unquantization-mapping>>.

[[uastc-endpoint-unquantization-mapping]]
.UASTC endpoint unquantization mapping
[width="75%",cols="3,8*1"]
|===============
| UASTC _Mode Index_ | 0 | 3 | 4 | 6 | 7 | 10 | 11 | 12
| Row in <<astc-color-unquantization-parameters>> | 0..191	| 0..11 | 0..39 | 0..159 | 0..39 | 0..47 | 0..47 | 0..191
|===============

* Constructing an intermediate value by shifting unpacked trit/quint left
  _num_ebits_ bits, logically OR in the endpoint bits and looking up the
  dequantized value using one of the following precomputed data in
  <<uastc-unquantization-data-3>>, <<uastc-unquantization-data-47>>,
  <<uastc-unquantization-data-1011>>, <<uastc-unquantization-data-6>>,
  and <<uastc-unquantization-data-012>>.
  Note that, after unquantization, the order of values is different.

For example, a _Mode Index_ 7 endpoint with a quint value of 4 and endpoint
bits value of 2 would yield (4 << 3) | 2 == 34. The 34-th element of the
relevant unquantization data is {9, 58}.
This means that the 8-bit endpoint value is 58/255 scaled from 9/39 (because
there are 40 quantized values total for this mode).

[[uastc-unquantization-data-3]]
.UASTC unquantization data for _Mode Index_ 3 (12 values)
[cols="3,12*1"]
|==========
| (_trit_ << 2) \| _bits_ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~ | ~8~ | ~9~ | ~10~ | ~11~
| Value /11 | 0 | 11 | 3 | 8 | 1 | 10 | 4 | 7 | 2 | 9 | 5 | 6
| Value /255 | 0 | 255 | 69 | 186 | 23 | 232 | 92 | 163 | 46 | 209 | 116 | 139
|==========

[[uastc-unquantization-data-47]]
.UASTC unquantization data for _Mode Indices_ 4 and 7 (40 values)
[cols="4,20*1"]
|==========
| (_quint_ << 3) \| _bits_ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~ | ~8~ | ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~ | ~16~ | ~17~ | ~18~ | ~19~
| Value / 39 | 0 | 39 | 5 | 34 | 10 | 29 | 15 | 24 | 1 | 38 | 6 | 33 | 11 | 28 | 16 | 23 | 2 | 37 | 7 | 32
| Value / 255 | 0 | 255 | 32 | 223 | 65 | 190 | 97 | 158 | 6 | 249 | 39 | 216 | 71 | 184 | 104 | 151 | 13 | 242 | 45 | 210
| (_quint_ << 3) \| _bits_ | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~ | ~32~ | ~33~ | ~34~ | ~35~ | ~36~ | ~37~ | ~38~ | ~39~
| Value / 39 | 12 | 27 | 17 | 22 | 3 | 36 | 8 | 31 | 13 | 26 | 18 | 21 | 4 | 35 | 9 | 30 | 14 | 25 | 19 | 20
| Value / 255 | 78 | 177 | 110 | 145 | 19 | 236 | 52 | 203 | 84 | 171 | 117 | 138 | 26 | 229 | 58 | 197 | 91 | 164 | 123 | 132
|==========

[[uastc-unquantization-data-1011]]
.UASTC unquantization data for _Mode Indices_ 10 and 11 (48 values)
[cols="3,16*1"]
|==========
| (_trit_ << 4) \| _bits_ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~ | ~8~ | ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| Value / 47 | 0 | 47 | 3 | 44 | 6 | 41 | 9 | 38 | 12 | 35 | 15 | 32 | 18 | 29 | 21 | 26
| Value / 255 | 0 | 255 | 16 | 239 | 32 | 223 | 48 | 207 | 65 | 190 | 81 | 174 | 97 | 158 | 113 | 142
| (_trit_ << 4) \| _bits_ | ~16~ | ~17~ | ~18~ | ~19~ | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~
| Value / 47 | 1 | 46 | 4 | 43 | 7 | 40 | 10 | 37 | 13 | 34 | 16 | 31 | 19 | 28 | 22 | 25
| Value / 255 | 5 | 250 | 21 | 234 | 38 | 217 | 54 | 201 | 70 | 185 | 86 | 169 | 103 | 152 | 119 | 136
| (_trit_ << 4) \| _bits_ | ~32~ | ~33~ | ~34~ | ~35~ | ~36~ | ~37~ | ~38~ | ~39~ | ~40~ | ~41~ | ~42~ | ~43~ | ~44~ | ~45~ | ~46~ | ~47~
| Value / 47 | 2 | 45 | 5 | 42 | 8 | 39 | 11 | 36 | 14 | 33 | 17 | 30 | 20 | 27 | 23 | 24
| Value / 255 | 11 | 244 | 27 | 228 | 43 | 212 | 59 | 196 | 76 | 179 | 92 | 163 | 108 | 147 | 124 | 131
|==========

[[uastc-unquantization-data-6]]
.UASTC unquantization data for _Mode Index_ 6 (160 values)
[cols="3,16*1"]
|==========
| (_quint_ << 5) \| _bits_ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~ | ~8~ | ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| Value / 159 | 0 | 159 | 5 | 154 | 10 | 149 | 15 | 144 | {20 | 139 | 25 | 134 | 30 | 129 | 35 | 124
| Value / 255 | 0 | 255 | 8 | 247 | 16 | 239 | 24 | 231 | 32 | 223 | 40 | 215 | 48 | 207 | 56 | 199
| (_quint_ << 5) \| _bits_ | ~16~ | ~17~ | ~18~ | ~19~ | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~
| Value / 159 | 40 | 119 | 45 | 114 | 50 | 109 | 55 | 104 | 60 | 99 | 65 | 94 | 70 | 89 | 75 | 84
| Value / 255 | 64 | 191 | 72 | 183 | 80 | 175 | 88 | 167 | 96 | 159 | 104 | 151 | 112 | 143 | 120 | 135
| (_quint_ << 5) \| _bits_ | ~32~ | ~33~ | ~34~ | ~35~ | ~36~ | ~37~ | ~38~ | ~39~ | ~40~ | ~41~ | ~42~ | ~43~ | ~44~ | ~45~ | ~46~ | ~47~
| Value / 159 | 1 | 158 | 6 | 153 | 11 | 148 | 16 | 143 | 21 | 138 | 26 | 133 | 31 | 128 | 36 | 123
| Value / 255 | 1 | 254 | 9 | 246 | 17 | 238 | 25 | 230 | 33 | 222 | 41 | 214 | 49 | 206 | 57 | 198
| (_quint_ << 5) \| _bits_ | ~48~ | ~49~ | ~50~ | ~51~ | ~52~ | ~53~ | ~54~ | ~55~ | ~56~ | ~57~ | ~58~ | ~59~ | ~60~ | ~61~ | ~62~ | ~63~
| Value / 159 | 41 | 118 | 46 | 113 | 51 | 108 | 56 | 103 | 61 | 98 | 66 | 93 | 71 | 88 | 76 | 83
| Value / 255 | 65 | 190 | 73 | 182 | 81 | 174 | 89 | 166 | 97 | 158 | 105 | 150 | 113 | 142 | 121 | 134
| (_quint_ << 5) \| _bits_ | ~64~ | ~65~ | ~66~ | ~67~ | ~68~ | ~69~ | ~70~ | ~71~ | ~72~ | ~73~ | ~74~ | ~75~ | ~76~ | ~77~ | ~78~ | ~79~
| Value / 159 | 2 | 157 | 7 | 152 | 12 | 147 | 17 | 142 | 22 | 137 | 27 | 132 | 32 | 127 | 37 | 122
| Value / 255 | 3 | 252 | 11 | 244 | 19 | 236 | 27 | 228 | 35 | 220 | 43 | 212 | 51 | 204 | 59 | 196
| (_quint_ << 5) \| _bits_ | ~80~ | ~81~ | ~82~ | ~83~ | ~84~ | ~85~ | ~86~ | ~87~ | ~88~ | ~89~ | ~90~ | ~91~ | ~92~ | ~93~ | ~94~ | ~95~
| Value / 159 | 42 | 117 | 47 | 112 | 52 | 107 | 57 | 102 | 62 | 97 | 67 | 92 | 72 | 87 | 77 | 82
| Value / 255 | 67 | 188 | 75 | 180 | 83 | 172 | 91 | 164 | 99 | 156 | 107 | 148 | 115 | 140 | 123 | 132
| (_quint_ << 5) \| _bits_ | ~96~ | ~97~ | ~98~ | ~99~ | ~100~ | ~101~ | ~102~ | ~103~ | ~104~ | ~105~ | ~106~ | ~107~ | ~108~ | ~109~ | ~110~ | ~111~
| Value / 159 | 3 | 156 | 8 | 151 | 13 | 146 | 18 | 141 | 23 | 136 | 28 | 131 | 33 | 126 | 38 | 121
| Value / 255 | 4 | 251 | 12 | 243 | 20 | 235 | 28 | 227 | 36 | 219 | 44 | 211 | 52 | 203 | 60 | 195
| (_quint_ << 5) \| _bits_ | ~112~ | ~113~ | ~114~ | ~115~ | ~116~ | ~117~ | ~118~ | ~119~ | ~120~ | ~121~ | ~122~ | ~123~ | ~124~ | ~125~ | ~126~ | ~127~
| Value / 159 | 43 | 116 | 48 | 111 | 53 | 106 | 58 | 101 | 63 | 96 | 68 | 91 | 73 | 86 | 78 | 81
| Value / 255 | 68 | 187 | 76 | 179 | 84 | 171 | 92 | 163 | 100 | 155 | 108 | 147 | 116 | 139 | 124 | 131
| (_quint_ << 5) \| _bits_ | ~128~ | ~129~ | ~130~ | ~131~ | ~132~ | ~133~ | ~134~ | ~135~ | ~136~ | ~137~ | ~138~ | ~139~ | ~140~ | ~141~ | ~142~ | ~143~
| Value / 159 | 4 | 155 | 9 | 150 | 14 | 145 | 19 | 140 | 24 | 135 | 29 | 130 | 34 | 125 | 39 | 120
| Value / 255 | 6 | 249 | 14 | 241 | 22 | 233 | 30 | 225 | 38 | 217 | 46 | 209 | 54 | 201 | 62 | 193
| (_quint_ << 5) \| _bits_ | ~144~ | ~145~ | ~146~ | ~147~ | ~148~ | ~149~ | ~150~ | ~151~ | ~152~ | ~153~ | ~154~ | ~155~ | ~156~ | ~157~ | ~158~ | ~159~
| Value / 159 | 44 | 115 | 49 | 110 | 54 | 105 | 59 | 100 | 64 | 95 | 69 | 90 | 74 | 85 | 79 | 80
| Value / 255 | 70 | 185 | 78 | 177 | 86 | 169 | 94 | 161 | 102 | 153 | 110 | 145 | 118 | 137 | 126 | 129
|==========

[[uastc-unquantization-data-012]]
.UASTC unquantization data for _Mode Indices_ 0 and 12 (192 values)
[cols="3,16*1"]
|==========
| (_trit_ << 6) \| _bits_ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~ | ~8~ | ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| Value / 191 | 0 | 191 | 3 | 188 | 6 | 185 | 9 | 182 | 12 | 179 | 15 | 176 | 18 | 173 | 21 | 170
| Value / 255 | 0 | 255 | 4 | 251 | 8 | 247 | 12 | 243 | 16 | 239 | 20 | 235 | 24 | 231 | 28 | 227
| (_trit_ << 6) \| _bits_ | ~16~ | ~17~ | ~18~ | ~19~ | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~
| Value / 191 | 24 | 167 | 27 | 164 | 30 | 161 | 33 | 158 | 36 | 155 | 39 | 152 | 42 | 149 | 45 | 146
| Value / 255 | 32 | 223 | 36 | 219 | 40 | 215 | 44 | 211 | 48 | 207 | 52 | 203 | 56 | 199 | 60 | 195
| (_trit_ << 6) \| _bits_ | ~32~ | ~33~ | ~34~ | ~35~ | ~36~ | ~37~ | ~38~ | ~39~ | ~40~ | ~41~ | ~42~ | ~43~ | ~44~ | ~45~ | ~46~ | ~47~
| Value / 191 | 48 | 143 | 51 | 140 | 54 | 137 | 57 | 134 | 60 | 131 | 63 | 128 | 66 | 125 | 69 | 122
| Value / 255 | 64 | 191 | 68 | 187 | 72 | 183 | 76 | 179 | 80 | 175 | 84 | 171 | 88 | 167 | 92 | 163
| (_trit_ << 6) \| _bits_ | ~48~ | ~49~ | ~50~ | ~51~ | ~52~ | ~53~ | ~54~ | ~55~ | ~56~ | ~57~ | ~58~ | ~59~ | ~60~ | ~61~ | ~62~ | ~63~
| Value / 191 | 72 | 119 | 75 | 116 | 78 | 113 | 81 | 110 | 84 | 107 | 87 | 104 | 90 | 101 | 93 | 98
| Value / 255 | 96 | 159 | 100 | 155 | 104 | 151 | 108 | 147 | 112 | 143 | 116 | 139 | 120 | 135 | 124 | 131
| (_trit_ << 6) \| _bits_ | ~64~ | ~65~ | ~66~ | ~67~ | ~68~ | ~69~ | ~70~ | ~71~ | ~72~ | ~73~ | ~74~ | ~75~ | ~76~ | ~77~ | ~78~ | ~79~
| Value / 191 | 1 | 190 | 4 | 187 | 7 | 184 | 10 | 181 | 13 | 178 | 16 | 175 | 19 | 172 | 22 | 169
| Value / 255 | 1 | 254 | 5 | 250 | 9 | 246 | 13 | 242 | 17 | 238 | 21 | 234 | 25 | 230 | 29 | 226
| (_trit_ << 6) \| _bits_ | ~80~ | ~81~ | ~82~ | ~83~ | ~84~ | ~85~ | ~86~ | ~87~ | ~88~ | ~89~ | ~90~ | ~91~ | ~92~ | ~93~ | ~94~ | ~95~
| Value / 191 | 25 | 166 | 28 | 163 | 31 | 160 | 34 | 157 | 37 | 154 | 40 | 151 | 43 | 148 | 46 | 145
| Value / 255 | 33 | 222 | 37 | 218 | 41 | 214 | 45 | 210 | 49 | 206 | 53 | 202 | 57 | 198 | 61 | 194
| (_trit_ << 6) \| _bits_ | ~96~ | ~97~ | ~98~ | ~99~ | ~100~ | ~101~ | ~102~ | ~103~ | ~104~ | ~105~ | ~106~ | ~107~ | ~108~ | ~109~ | ~110~ | ~111~
| Value / 191 | 49 | 142 | 52 | 139 | 55 | 136 | 58 | 133 | 61 | 130 | 64 | 127 | 67 | 124 | 70 | 121
| Value / 255 | 65 | 190 | 69 | 186 | 73 | 182 | 77 | 178 | 81 | 174 | 85 | 170 | 89 | 166 | 93 | 162
| (_trit_ << 6) \| _bits_ | ~112~ | ~113~ | ~114~ | ~115~ | ~116~ | ~117~ | ~118~ | ~119~ | ~120~ | ~121~ | ~122~ | ~123~ | ~124~ | ~125~ | ~126~ | ~127~
| Value / 191 | 73 | 118 | 76 | 115 | 79 | 112 | 82 | 109 | 85 | 106 | 88 | 103 | 91 | 100 | 94 | 97
| Value / 255 | 97 | 158 | 101 | 154 | 105 | 150 | 109 | 146 | 113 | 142 | 117 | 138 | 121 | 134 | 125 | 130
| (_trit_ << 6) \| _bits_ | ~128~ | ~129~ | ~130~ | ~131~ | ~132~ | ~133~ | ~134~ | ~135~ | ~136~ | ~137~ | ~138~ | ~139~ | ~140~ | ~141~ | ~142~ | ~143~
| Value / 191 | 2 | 189 | 5 | 186 | 8 | 183 | 11 | 180 | 14 | 177 | 17 | 174 | 20 | 171 | 23 | 168
| Value / 255 | 2 | 253 | 6 | 249 | 10 | 245 | 14 | 241 | 18 | 237 | 22 | 233 | 26 | 229 | 30 | 225
| (_trit_ << 6) \| _bits_ | ~144~ | ~145~ | ~146~ | ~147~ | ~148~ | ~149~ | ~150~ | ~151~ | ~152~ | ~153~ | ~154~ | ~155~ | ~156~ | ~157~ | ~158~ | ~159~
| Value / 191 | 26 | 165 | 29 | 162 | 32 | 159 | 35 | 156 | 38 | 153 | 41 | 150 | 44 | 147 | 47 | 144
| Value / 255 | 34 | 221 | 38 | 217 | 42 | 213 | 46 | 209 | 50 | 205 | 54 | 201 | 58 | 197 | 62 | 193
| (_trit_ << 6) \| _bits_ | ~160~ | ~161~ | ~162~ | ~163~ | ~164~ | ~165~ | ~166~ | ~167~ | ~168~ | ~169~ | ~170~ | ~171~ | ~172~ | ~173~ | ~174~ | ~175~
| Value / 191 | 50 | 141 | 53 | 138 | 56 | 135 | 59 | 132 | 62 | 129 | 65 | 126 | 68 | 123 | 71 | 120
| Value / 255 | 66 | 189 | 70 | 185 | 74 | 181 | 78 | 177 | 82 | 173 | 86 | 169 | 90 | 165 | 94 | 161
| (_trit_ << 6) \| _bits_ | ~176~ | ~177~ | ~178~ | ~179~ | ~180~ | ~181~ | ~182~ | ~183~ | ~184~ | ~185~ | ~186~ | ~187~ | ~188~ | ~189~ | ~190~ | ~191~
| Value / 191 | 74 | 117 | 77 | 114 | 80 | 111 | 83 | 108 | 86 | 105 | 89 | 102 | 92 | 99 | 95 | 96
| Value / 255 | 98 | 157 | 102 | 153 | 106 | 149 | 110 | 145 | 114 | 141 | 118 | 137 | 122 | 133 | 126 | 129
|==========

===== Deriving missing _RGBA_ values

For _Mode Indices_ 15, 16, and 17, _RGB_ endpoint values are derived from *_L*_*
unquantized values as

*_RL0_* = *_GL0_* = *_BL0_* = *_LL0_*

*_RH0_* = *_GH0_* = *_BH0_* = *_LH0_*

For _Mode Index_ 16 only:

*_RL1_* = *_GL1_* = *_BL1_* = *_LL1_*

*_RH1_* = *_GH1_* = *_BH1_* = *_LH1_*

For _Mode Indices_ 0..7, and 18, all _Alpha_ endpoint values must be set to 255.

ifndef::a2xhtml[]

<<<

&nbsp;

<<<

&nbsp;

<<<

endif::[]

===== Unquantizing weights

Weights are stored with 1..5 bits.
They must be dequantized to 6-bit interpolation values.
This could be done with either of these approaches:

* Using <<astc-weight-unquantization,ASTC Weights Unquantization>>.
  UASTC _num_wbits_ values refer to bit-only representations, and
  so are expanded to 6-bit values by bit replication, then have the
  final ++if (unq > 32) { unq += 1; }++ step applied.

* Using precomputed data to get unquantized weights directly, as
  shown in <<uastc-unquantization-weights>>.

[[uastc-unquantization-weights]]
.UASTC unquantization values for weight expansion
[cols="3,16*1"]
|=========
| ~_num_wbits_~ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~ | ~8~ | ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| 1             | 0 | 64 | | | | | | | | | | | | | |
| 2             | 0 | 21 | 43 | 64 | | | | | | | | | | | |
| 3             | 0 | 9 | 18 | 27 | 37 | 46 | 55 | 64 | | | | | | | |
| 4             | 0 | 4 | 8 | 12 | 17 | 21 | 25 | 29 | 35 | 39 | 43 | 47 | 52 | 56 | 60 | 64
| 5             | 0 | 2| 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24 | 26 | 28 | 30
| ~_num_wbits_~ | ~16~ | ~17~ | ~18~ | ~19~ | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~
| 5             | 34 | 36| 38 | 40 | 42 | 44 | 46 | 48 | 50 | 52 | 54 | 56 | 58 | 60 | 62 | 64
|=========

===== Decoding pixel values

To decode each pixel's 8-bit _RGBA_ value, the decoder needs to have
dequantized endpoints, weights, and parsed configuration data as
described in the sections above.

The final value of each color channel is computed as a weighted sum of
the block's endpoints.

[[uastc-onesubsetsingleplane]]
===== One subset, single plane

This process is applied to blocks with _Mode Indices_ 0, 1, 5, 10, 12,
14, 15, and 18.

First, unquantized endpoint values are expanded to 16 bits.
If sRGB conversion is not enabled, this is performed by bit replication.
If sRGB conversion is enabled, channels are expanded by left-shifting each
value 8 bits and logically ORing 0x80.

-----
RL0 = (RL0 << 8) | (is_srgb ? 0x80 : RL0)
RH0 = (RH0 << 8) | (is_srgb ? 0x80 : RH0)
GL0 = (GL0 << 8) | (is_srgb ? 0x80 : GL0)
GH0 = (GH0 << 8) | (is_srgb ? 0x80 : GH0)
BL0 = (BL0 << 8) | (is_srgb ? 0x80 : BL0)
BH0 = (BH0 << 8) | (is_srgb ? 0x80 : BH0)
AL0 = (AL0 << 8) | (is_srgb ? 0x80 : AL0)
AH0 = (AH0 << 8) | (is_srgb ? 0x80 : AH0)
-----

Then, the final values are computed as follows:

-----
C = ((CL * (64 - W) + CH * W + 32) >> 6) >> 8
-----

Note that this description corresponds to conversion to ASTC and then
extracting the color channels as described for decode mode
++decode_unorm8++ in <<astc_weight_application>> of
<<ASTC,ASTC>>.

++CL++ and ++CH++ are 4-component _RGBA_ endpoints, ++W++ is an unquantized
6-bit weight value taken from the ++WEIGHTS0++ array, and ++C++ is the
resulting pixel value.

===== One subset, dual plane

This process is applied to blocks with _Mode Indices_ 6, 11, 13, and 17.

Decoding proceeds as in the previous section with the only difference being
that one color channel uses weights from the ++WEIGHTS1++ array.
The selection of that channel is based on the following rules.

For blocks with _Mode Indices_ 6, 11, and 13, the separately-interpolated
channel is selected based on the value of the *CSEL* field as shown
in <<uastc-table-compsel>>.

[[uastc-table-compsel]]
.UASTC *CSEL* field
[options="header",width="50%"]
|=======
| *CSEL*  | WEIGHTS0       | WEIGHTS1
| 0	      | _G_, _B_, _A_  | _R_
| 1	      | _R_, _B_, _A_  | _G_
| 2	      | _R_, _G_, _A_  | _B_
| 3	      | _R_, _G_, _B_  | _A_
|=======

Note that since _Mode Index_ 6 Alpha endpoints are always 255, decoders could
safely ignore WEIGHTS1 values when encountering such blocks with *CSEL*
value of 3.

For blocks with _Mode Index_ 17, the separately-interpolated channel is
always Alpha.

===== Two subsets

This process is applied to blocks with _Mode Indices_ 2, 4, 7, 9, and 16.

These blocks have 2 sets of endpoint values and the partition pattern
index (PAT) defines which set each pixel belongs to.

For blocks with _Mode Index_ 7, there are 19 total partition patterns, with
the partition indices for each pixel defined in <<uastc-subsets-mode7>>.

[[uastc-subsets-mode7]]
.Partition table for 2-subset _Mode Index_ 7, with the 4×4 block of values for each PAT value
[cols="5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5",width="70%"]
|==================
4+^|              ~0~      1.20+| 4+^|                ~1~      1.20+| 4+^|                ~2~      1.20+| 4+^|                ~3~      1.15+| 4+^|                ~4~
^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_0_* ^|   0   ^| *_1_* ^|   0   ^| *_1_* ^|   1   ^| *_0_* ^|   0   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1
^| *_1_* ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^|   1
^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0
^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1
4+^|              ~5~             4+^|                ~6~             4+^|                ~7~             4+^|                ~8~             4+^|                ~9~
^| *_0_* ^| *_1_* ^|   0   ^|   0   ^| *_0_* ^|   0   ^|   0   ^| *_1_* ^| *_0_* ^| *_1_* ^|   1   ^|   1   ^| *_1_* ^|   1   ^| *_0_* ^|   0   ^| *_0_* ^| *_1_* ^|   1   ^|   1
^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1
^|   0   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0
^|   0   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0
4+^|             ~10~             4+^|               ~11~             4+^|               ~12~             4+^|               ~13~             4+^|               ~14~
^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^| *_0_* ^|   0   ^| *_0_* ^| *_1_* ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1
^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^|   1
^| *_1_* ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1
^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   1   ^|   1   ^|   0
4+^|             ~15~             4+^|               ~16~             4+^|               ~17~             4+^|               ~18~           5.5+^|
^| *_1_* ^|   1   ^| *_0_* ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^| *_1_* ^|   1   ^| *_1_* ^|   1   ^|   1   ^|   1
^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0   ^| *_0_* ^|   1   ^|   1   ^|   1
^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0
^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0
|==================

For other blocks (with _Mode Indices_ 2, 4, 9, and 16), there are 30 total
partition patterns and the partition indices for each pixel are defined
in <<uastc-subsets-mode24916>>.

[[uastc-subsets-mode24916]]
.Partition table for 2-subset _Mode Indices_ 2, 4, 9, and 16, with the 4×4 block of values for each PAT value
[cols="5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5",width="90%"]
|==================
4+^|              ~0~      1.25+| 4+^|                ~1~      1.25+| 4+^|                ~2~      1.25+| 4+^|                ~3~      1.25+| 4+^|                ~4~      1.25+| 4+^|                ~5~
^| *_0_* ^|   0   ^| *_1_* ^|   1   ^| *_0_* ^|   0   ^|   0   ^| *_1_* ^| *_1_* ^| *_0_* ^|   0   ^|   0   ^| *_0_* ^|   0   ^|   0   ^| *_1_* ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^| *_1_* ^|   1
^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   1   ^|   1   ^|   1
^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1
^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1
4+^|              ~6~             4+^|                ~7~             4+^|                ~8~             4+^|                ~9~             4+^|               ~10~             4+^|               ~11~
^| *_1_* ^|   1   ^|   1   ^| *_0_* ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^| *_0_* ^|   0   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1
^|   1   ^|   1   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^|   1
^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_0_*
^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0
4+^|             ~12~             4+^|               ~13~             4+^|               ~14~             4+^|               ~15~             4+^|               ~16~             4+^|               ~17~
^| *_1_* ^|   1   ^|   1   ^| *_0_* ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^| *_0_* ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1
^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_1_* ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1
^|   0   ^|   0   ^|   0   ^|   0   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   1   ^|   1   ^|   1
^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1
4+^|             ~18~             4+^|               ~19~             4+^|               ~20~             4+^|               ~21~             4+^|               ~22~             4+^|               ~23~
^| *_0_* ^| *_1_* ^|   1   ^|   1   ^| *_0_* ^|   0   ^| *_1_* ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^| *_0_* ^|   0   ^|   0   ^| *_0_* ^|   0   ^| *_1_* ^|   1
^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^| *_1_* ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1
^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^| *_0_* ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1
^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0
4+^|             ~24~             4+^|               ~25~             4+^|               ~26~             4+^|               ~27~             4+^|               ~28~             4+^|               ~29~
^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_0_* ^| *_1_* ^|   1   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^| *_0_* ^|   1   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^| *_0_* ^|   0   ^|   1
^| *_0_* ^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   1   ^|   0   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1
^|   0   ^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   0   ^|   1   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0
^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   1   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   0   ^|   0
|==================

Decoding proceeds as in <<uastc-onesubsetsingleplane>>
with the only difference being that pixels belonging to the second subset
use the second set of endpoint values (*_RL1_*, *_RH1_*, *_GL1_*, *_GH1_*,
*_BL1_*, *_BH1_*, *_AL1_*, and *_AH1_*).

<<<

===== Three subsets

This process is applied to blocks with _Mode Index_ 3.

These blocks have 3 sets of endpoint values and partition pattern index (PAT)
defines to which set each pixel belongs.

There are 11 total partition patterns, for which the partition indices for each
pixel are defined in <<uastc-subsets-mode3>>.

[[uastc-subsets-mode3]]
.Partition table for 3-subset _Mode Index_ 3, with the 4×4 block of values for each PAT value
[cols="5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5,1,5,5,5,5",width="90%"]
|==================
4+^|              ~0~      1.10+| 4+^|                ~1~      1.10+| 4+^|                ~2~      1.10+| 4+^|                ~3~      1.10+| 4+^|                ~4~       1.5+| 4+^|                ~5~
^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_1_* ^|   1   ^| *_2_* ^| *_0_* ^| *_0_* ^| *_1_* ^|   1   ^| *_2_*
^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^|   0   ^|   0   ^| *_2_* ^|   2   ^|   2   ^|   2   ^|   1   ^|   1   ^|   2   ^|   0   ^|   0   ^|   1   ^|   1   ^|   2
^| *_1_* ^|   1   ^| *_2_* ^|   2   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   2   ^|   0   ^|   0   ^|   1   ^|   1   ^|   2
^|   1   ^|   1   ^|   2   ^|   2   ^| *_2_* ^|   2   ^|   2   ^|   2   ^| *_2_* ^|   2   ^|   2   ^|   2   ^|   0   ^|   0   ^|   0   ^|   0   ^|   1   ^|   1   ^|   2   ^|   0   ^|   0   ^|   1   ^|   1   ^|   2
4+^|              ~6~             4+^|                ~7~             4+^|                ~8~             4+^|                ~9~             4+^|               ~10~           5.5+^|
^| *_0_* ^| *_2_* ^| *_1_* ^|   1   ^| *_2_* ^| *_0_* ^|   0   ^|   0   ^| *_2_* ^| *_0_* ^| *_1_* ^|   2   ^| *_1_* ^|   1   ^|   1   ^|   1   ^| *_0_* ^|   0   ^| *_2_* ^|   2
^|   0   ^|   2   ^|   1   ^|   1   ^|   2   ^|   0   ^|   0   ^|   0   ^|   2   ^|   0   ^|   1   ^|   2   ^| *_0_* ^|   0   ^|   0   ^|   0   ^|   0   ^|   0   ^| *_1_* ^|   1
^|   0   ^|   2   ^|   1   ^|   1   ^|   2   ^| *_1_* ^|   1   ^|   1   ^|   2   ^|   0   ^|   1   ^|   2   ^| *_2_* ^|   2   ^|   2   ^|   2   ^|   0   ^|   0   ^|   1   ^|   1
^|   0   ^|   2   ^|   1   ^|   1   ^|   2   ^|   1   ^|   1   ^|   1   ^|   2   ^|   0   ^|   1   ^|   2   ^|   1   ^|   1   ^|   1   ^|   1   ^|   0   ^|   0   ^|   2   ^|   2
|==================

Decoding proceeds as in the previous section section with the only difference
being that pixels belonging to the third subset use the third set of endpoint
values (*_RL2_*, *_RH2_*, *_GL2_*, *_GH2_*, *_BL2_*, *_BH2_*, *_AL2_*, and
*_AH2_*).

<<<

=== Transcoding UASTC blocks to other compressed formats

To take advantage of hardware texture decoders, UASTC blocks can be transcoded
to natively-supported compressed texture formats. Regardless of the target
format, transcoding always starts with parsing the UASTC block as described in
the <<uastc-bitstream-format,Bitstream format>> section above.

==== Transcoding to ASTC

Transcoding UASTC to ASTC is always a 100% lossless operation.
Only 4{times}4 LDR ASTC blocks are supported as transcode targets.

===== Solid color blocks

_Mode Index_ 8 UASTC blocks correspond to void-extent ASTC blocks.
The following rules apply:

8-bit UASTC _RGBA_ values are extended to 16-bit by bit replication before
being written to the ASTC block:

-----
Rastc = (R << 8) | R
Gastc = (G << 8) | G
Bastc = (B << 8) | B
Aastc = (A << 8) | A
-----

The ASTC Dynamic Range flag must be set to 0.

All minimum and maximum void-extent coordinate bits must be set to 1.

<<<

===== Interpolated blocks

Each UASTC _Mode Index_ corresponds to a fixed set of ASTC configuration parameters,
including endpoint range, as defined in <<uastc-astc-config>>.
When the block contains multiple subsets, all endpoint pairs use the same CEM.

[[uastc-astc-config]]
.UASTC to ASTC configuration mapping
[options="header",width="95%",cols="2,2,2,2,1,3"]
|===============
| UASTC _Mode Index_ | ASTC Mode | Weight Range | Endpoint Range | Subsets | ASTC CEM
|       0            | 578       |     0..15    |     0..191     |    1    | 8 (Direct _RGB_)
|       1            | 66        |      0..3    |     0..255     |    1    | 8 (Direct _RGB_)
|       2            | 83        |      0..7    |     0..15      |    2    | 8 (Direct _RGB_)
|       3            | 66        |      0..3    |     0..11      |    3    | 8 (Direct _RGB_)
|       4            | 66        |      0..3    |     0..39      |    2    | 8 (Direct _RGB_)
|       5            | 83        |      0..7    |     0..255     |    1    | 8 (Direct _RGB_)
|       6            | 1090 (Dp) |      0..3    |     0..159     |    1    | 8 (Direct _RGB_)
|       7            | 66        |      0..3    |     0..39      |    2    | 8 (Direct _RGB_)
|       9            | 66        |      0..3    |     0..15      |    2    | 12 (Direct _RGBA_)
|       10           | 578       |     0..15    |     0..47      |    1    | 12 (Direct _RGBA_)
|       11           | 1090 (Dp) |      0..3    |     0..47      |    1    | 12 (Direct _RGBA_)
|       12           | 83        |      0..7    |     0..191     |    1    | 12 (Direct _RGBA_)
|       13           | 1089 (Dp) |      0..1    |     0..255     |    1    | 12 (Direct _RGBA_)
|       14           | 66        |      0..3    |     0..255     |    1    | 12 (Direct _RGBA_)
|       15           | 578       |     0..15    |     0..255     |    1    | 4 (Direct _LA_)
|       16           | 66        |      0..3    |     0..255     |    2    | 4 (Direct _LA_)
|       17           | 1090 (Dp) |      0..3    |     0..255     |    1    | 4 (Direct _LA_)
|       18           | 595       |     0..31    |     0..31      |    1    | 8 (Direct _RGB_)
|===============

UASTC endpoints and weights require only repacking (and reordering in some
cases, see below) when transcoded to ASTC.
No per-pixel processing or full block decoding is needed.

<<<

===== Multi-subset blocks

For each UASTC partition pattern there is a seed value for ASTC partition
generator that produces the same pattern in the ASTC decoder.
That seed value (ASTC Partition Index) is derived from UASTC *_PAT_* value.

When UASTC _Mode Index_ is 2, 4, 9, or 16, the value of ASTC Partition
Index depends on *_PAT_* as shown in <<uastc-astc-pat-mode24916>>.

[[uastc-astc-pat-mode24916]]
.ASTC Partition Index for UASTC *_PAT_* values in _Mode Indices_ 2, 4, 9, or 16
[width="90%",cols="5,10*1"]
|==================
|        ~UASTC _PAT_~ |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~ |  ~8~ |  ~9~
| ASTC Partition Index |  28  |  20  |  16  |  29  |  91  |   9  |  107 |  72  |  149 |  204
|        ~UASTC _PAT_~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~ | ~16~ | ~17~ | ~18~ | ~19~
| ASTC Partition Index |  50  | 114  | 496  |  17  |  78  |  39  | 252  | 828  |  43  | 156
|        ~UASTC _PAT_~ | ~20~ | ~21~ | ~22~ | ~23~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~
| ASTC Partition Index | 116  | 210  | 476  | 273  | 684  | 359  | 246  | 195  | 694  | 524
|==================

When the UASTC _Mode Index_ is 3, the value of the ASTC Partition Index
depends on *_PAT_* as shown in <<uastc-astc-pat-mode3>>.

[[uastc-astc-pat-mode3]]
.ASTC Partition Index for UASTC *_PAT_* values in _Mode Index_ 3
[width="90%",cols="5,11*1"]
|==================
|        ~UASTC _PAT_~ |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~ |  ~8~ |  ~9~ | ~10~
| ASTC Partition Index | 260  |  74  |  32  | 156  | 183  |  15  | 745  |   0  | 335  | 902  | 254
|==================

When the UASTC _Mode Index_ is 7, the value of ASTC Partition Index
depends on *_PAT_* as shown in <<uastc-astc-pat-mode7>>.

[[uastc-astc-pat-mode7]]
.ASTC Partition Index for UASTC *_PAT_* values in _Mode Index_ 7
[width="90%",cols="5,10*1"]
|==================
|        ~UASTC _PAT_~ |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~ |  ~8~ |  ~9~
| ASTC Partition Index |  36  |  48  |  61  | 137  | 161  | 183  | 226  | 281  | 302  | 307
|        ~UASTC _PAT_~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~ | ~16~ | ~17~ | ~18~ |
| ASTC Partition Index | 479  | 495  | 593  | 594  | 605  | 799  | 812  | 988  | 993  |
|==================

<<<

===== Endpoints

UASTC endpoint pairs must be repacked according to ASTC BISE
specification by interleaving bits with trits or quints.
When the CEM value is 8 or 12, transcoders must ensure that the
order of each endpoint pair does not cause Blue Contraction by
swapping low and high values and inverting weights.

-----
if (RLi + GLi + BLi > RHi + GHi + BHi) {
    swap(RLi, RHi);
    swap(GLi, GHi);
    swap(GLi, GHi);

    foreach (w in weights) {
        w = max_weight_index - w;
    }
}
-----

===== Weights

UASTC weight values must be packed in reverse bit order starting
from the end of the ASTC block as described in
<<astc-weight-decoding>>.
Transcoded ASTC blocks always use a 4{times}4 grid of weights.

Note that UASTC weight ranges do not use trits or quints.

===== Dual-plane blocks

For _RGB_ and _RGBA_ dual-plane blocks (_Mode Indices_ 6, 11, and 13),
the _CCS_ value is set directly from *CSEL* UASTC field.

For _LA_ dual-plane blocks (_Mode Index_ 17), the _CCS_ value must be
set to 3.

<<<

==== Transcoding to BC7

Transcoding UASTC to BC7 is nearly a lossless operation.
The primary source of loss is mapping UASTC endpoints to BC7 endpoints.
This is done using a simple scale with optional optimal p-bit computation.
The UASTC weight indices are either copied as-is, or converted to the
closest corresponding BC7 weight indices using a lookup table.
The partition patterns are lossless, the weight tables are the same for
2/3-bits and very similar for 4-bits, and the endpoint interpolation
method is nearly the same (16-bits in UASTC, 8-bits with BC7, and both
formats use [0, 64] weights with rounding in the linear interpolation).

===== Solid color blocks

_Mode Index_ 8 UASTC blocks should be transcoded to BC7 mode 5 or mode 6
as follows:

To encode a solid-color block using BC7 mode 5, each two-bit pixel index
IB in the BC7 texel block should be set to the two-bit value 1, indicating
a 6-bit weight of 21.
The endpoints _E_ for the BC7 texel block should then be selected for each
channel _C_ as follows:

[latexmath]
++++++
\begin{align*}
\textit{E}_0 &= \textit{C} \gg 1 \\
\textit{E}_1 &= \begin {cases}
    {(\textit{C} \gg 1) + 1}, & \textit{C} < 128 \; \&\& \; \textit{C}\textrm{ is odd} \\
    {(\textit{C} \gg 1) - 1}, & \textit{C} > 127 \; \&\& \; \textit{C}\textrm{ is even} \\
    {\textit{C} \gg 1}, & \textrm{otherwise}
  \end{cases}
\end{align*}
++++++

The alpha channel for BC7 mode 5 is described with 8 bits, so both alpha
endpoints can be set to exactly the 8-bit value encoded in the UASTC solid
color block, and the secondary index bits IB~2~ can be set to 0.

To encode a solid-color block using BC7 mode 6, each four-bit pixel index
in the BC7 texel block should be set to the four-bit value 7, indicating
a 6-bit weight of 30.
If more channels contain 255 than contain 0, _EPB~0~_, and _EPB~1~_ should
be set to 1; otherwise _EPB~0~_ and _EPB~1~_ should be set to 0.

The endpoints _E_ for the BC7 texel block should then be selected for each
channel _C_ as follows:

[latexmath]
++++++
\begin{align*}
\textit{E}_0 &= \textit{C} \gg 1 \\
\textit{E}_1 &= \begin {cases}
    {(\textit{C} \gg 1) + 1}, & \textit{EPB}_{0,1} = 0 \; \&\& \; \textit{C}\textrm{ is odd} \\
    {(\textit{C} \gg 1) - 1}, & \textit{EPB}_{0,1} = 1 \; \&\& \; \textit{C}\textrm{ is even} \\
    {\textit{C} \gg 1}, & \textrm{otherwise}
  \end{cases}
\end{align*}
++++++

For both modes, other choices of endpoints and weights are also capable
of encoding the same values; the approaches shown above are recommended
for consistency.
Note that it is not possible to represent channels of both 255 and 0
concurrently using BC7 mode 6 due to both weights and _EPB_ values being
shared between channels, so these cases will require the use of BC7 mode 5
to record values exactly.
In other cases, the use of BC7 mode 6 is considered preferable for further
image compression.

<<<

===== Interpolated blocks

Each UASTC _Mode Index_ maps to a single BC7 mode.
Depending on the block's configuration, transcoders may need to convert
partition indices, scale and/or invert weights, swap endpoint pairs, and
swap color channels.
For BC7 modes with p-bits, transcoders also need to compute their optimal
values.
<<uastc-bc7-modes>> provides a high-level overview of these steps, and
subsequent sections describe each of them in detail.

[[uastc-bc7-modes]]
.UASTC to BC7 mode mapping
[options="header",width="85%",cols="1,1,1,1,2,1,1"]
|===============
| UASTC _Mode Index_ | BC7 Mode | Subsets | Weights scale | Weights order  | BC7 EP bits | P-bits
|        0           |    6     | single  |     copy      |  copy          |  7777       | endpoint
|        1           |    3     | 1-to-2  |     copy      |  check anchors |  7770       | endpoint
|        2           |    1     | 2-to-2  |     copy      |  check anchors |  6660       | subset
|        3           |    2     | 3-to-3  |     copy      |  check anchors |  5550       | no
|        4           |    3     | 2-to-2  |     copy      |  check anchors |  7770       | endpoint
|        5           |    6     | single  |    3-to-4     |  copy          |  7777       | endpoint
|        6           |    5     | single  |     copy      |  copy          |  7778       | no
|        7           |    2     | 2-to-3  |     copy      |  check anchors |  5550       | no
|        9           |    7     | 2-to-2  |     copy      |  check anchors |  5555       | endpoint
|       10           |    6     | single  |     copy      |  copy          |  7777       | endpoint
|       11           |    5     | single  |     copy      |  copy          |  7778       | no
|       12           |    6     | single  |    3-to-4     |  copy          |  7777       | endpoint
|       13           |    5     | single  |    1-to-2     |  copy          |  7778       | no
|       14           |    6     | single  |    2-to-4     |  copy          |  7777       | endpoint
|       15           |    6     | single  |     copy      |  copy          |  7777       | endpoint
|       16           |    7     | 2-to-2  |     copy      |  check anchors |  5555       | endpoint
|       17           |    5     | single  |     copy      |  copy          |  7778       | no
|       18           |    6     | single  |    5-to-4     |  copy          |  7777       | endpoint
|===============

NOTE: Solid color (_RGB_) UASTC modes 0, 5, and 18 are transcoded to _RGBA_
BC7 mode 6; minimizing the overall error when choosing EP bits may result
in BC7 values that are incompletely opaque (_Alpha_ = 254).

<<<

===== Multi-subset blocks

For each UASTC partition pattern there is a BC7 partition index that,
combined with endpoint pairs reordering, produces the same pattern in
the BC7 decoder.
That partition index depends on the UASTC *_PAT_* value.

When UASTC _Mode Index_ is 1, the value of BC7 partition index must be 0 and
single UASTC endpoint pair must be replicated to both BC7 endpoint pairs.

When UASTC _Mode Index_ is 2, 4, 9, or 16, the value of BC7 partition index
and subset order depends on *_PAT_* as shown in <<uastc-bc7-pat-mode24916>>.

[[uastc-bc7-pat-mode24916]]
.BC7 partition index and subset order for UASTC *_PAT_* values in _Mode Indices_ 2, 4, 9, or 16
[width="80%",cols="4,10*1"]
|==================
|       ~UASTC _PAT_~ |  ~0~  |  ~1~  |  ~2~  |  ~3~  |  ~4~  |  ~5~  |  ~6~  |  ~7~  |  ~8~  |  ~9~
| BC7 partition index |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9
| BC7 subset order    | {0,1} | {0,1} | {1,0} | {0,1} | {1,0} | {0,1} | {1,0} | {1,0} | {0,1} | {1,0}
|       ~UASTC _PAT_~ | ~10~  | ~11~  | ~12~  | ~13~  | ~14~  | ~15~  | ~16~  | ~17~  | ~18~  | ~19~
| BC7 partition index |  10   |  11   |  12   |  13   |  14   |  15   |  17   |  18   |  19   |  20
| BC7 subset order    | {0,1} | {1,0} | {1,0} | {1,0} | {0,1} | {1,0} | {1,0} | {1,0} | {0,1} | {0,1}
|       ~UASTC _PAT_~ | ~20~  | ~21~  | ~22~  | ~23~  | ~24~  | ~25~  | ~26~  | ~27~  | ~28~  | ~29~
| BC7 partition index |  21   |  22   |  23   |  24   |  25   |  26   |  29   |  32   |  33   |  52
| BC7 subset order    | {0,1} | {1,0} | {1,0} | {0,1} | {1,0} | {0,1} | {1,0} | {1,0} | {1,0} | {1,0}
|==================

When UASTC _Mode Index_ is 3, the value of BC7 partition index and subset
order depends on *_PAT_* as shown in <<uastc-bc7-pat-mode3>>.

[[uastc-bc7-pat-mode3]]
.BC7 partition index and subset order for UASTC *_PAT_* values in _Mode Index_ 3
[width="95%",cols="3,11*1"]
|==================
|       ~UASTC _PAT_~ |   ~0~   |   ~1~   |   ~2~   |   ~3~   |   ~4~   |   ~5~   |   ~6~   |   ~7~   |   ~8~   |   ~9~   |  ~10~
| BC7 partition index |    4    |    8    |    9    |   10    |   11    |   12    |   13    |   20    |   35    |   36    |   57
| BC7 subset order    | {0,1,2} | {1,0,2} | {1,0,2} | {1,2,0} | {1,2,0} | {0,1,2} | {0,2,1} | {2,0,1} | {2,0,1} | {1,0,2} | {0,1,2}
|==================

For example, UASTC _Mode Index_ 3, *_PAT_* 8 has 3 endpoint pairs and maps to
BC7 partition 35 with order {1, 2, 0}.
This means that BC7 subset 0 must use UASTC subset 1, BC7 subset 1 must use
UASTC subset 2, and BC7 subset 2 must use UASTC subset 0.

When UASTC _Mode Index_ is 7, the value of BC7 partition index and subset
order depends on *_PAT_* as shown in <<uastc-bc7-pat-mode7>>.
(These are 3-subset BC7 partitions, but only 2 subsets from those patterns
are used by setting two of the BC7 endpoint pairs to the same values.)

[[uastc-bc7-pat-mode7]]
.BC7 partition index and subset order for UASTC *_PAT_* values in _Mode Index_ 7
[width="85%",cols="3,10*1"]
|==================
|       ~UASTC _PAT_~ |   ~0~   |   ~1~   |   ~2~   |   ~3~   |   ~4~   |   ~5~   |   ~6~   |   ~7~   |   ~8~   |   ~9~
| BC7 partition index |   10    |   11    |    0    |    2    |    8    |   13    |    1    |   33    |   40    |   20
| BC7 subset order    | {0,1,0} | {0,1,0} | {1,0,0} | {0,1,0} | {1,0,1} | {0,1,0} | {0,1,1} | {0,1,1} | {1,0,0} | {0,1,0}
|       ~UASTC _PAT_~ |  ~10~   |  ~11~   |  ~12~   |  ~13~   |  ~14~   |  ~15~   |  ~16~   |  ~17~   |  ~18~   1.3+|
| BC7 partition index |   21    |   58    |    3    |   32    |   59    |   34    |   20    |   14    |   31
| BC7 subset order    | {0,0,1} | {1,0,0} | {0,0,1} | {0,1,1} | {1,1,0} | {1,0,0} | {1,1,0} | {0,1,0} | {1,0,0}
|==================

<<<

===== Endpoints

UASTC endpoints must be unquantized to 8-bit range as described in
<<uastc-unquantizing-endpoints>>.

For BC7 modes without p-bits (2 and 5), unquantized endpoint values must be scaled
to the target number of BC7 endpoint bits (5 or 7 respectively).

The following equations must be used (with integer division):

-----
bc7_5bit_ep = (uastc_ep * 31 + 127) / 255
bc7_7bit_ep = (uastc_ep * 127 + 127) / 255
-----

For all other modes, unquantized values must first be normalized to [0.0, 1.0]
floating-point range by dividing them by 255.0.
Optimal BC7 quantized endpoint colors and p-bits must be computed using the
functions included below.

===== Common helpers

* *clamp(int x, int min, int max)* Clamps integer x to the [min, max] inclusive range.
* *squaref(float x)* Returns x * x floating-point value.
* *(int)(float x)* Casts floating-point x value to integer, discarding the
  fractional part.

<<<

===== Subset P-bits computation

This routine computes optimal p-bit value per subset (used only in BC7 mode 1).

_Inputs (for each subset):_

* *xl[3] and xh[3]* Floating-point _RGB_ endpoint values ([0.0, 1.0]).

_Outputs (for each subset):_

* *bestMinColor[3]* and *bestMaxColor[3]* Quantized 6-bit _RGB_ values.
* *bestPbit* P-bit value.

_Helpers:_

* *clamp(int x, int min, int max)* Clamps integer x to the [min, max] inclusive range.
* *squaref(float x)* Returns x * x floating-point value.
* *(int)(float x)* Casts floating-point x value to integer, discarding the fractional part.

-----
float best_err = 1e+9f;

for (int p = 0; p < 2; p++)
{
    uint8_t xMinColor[3], xMaxColor[3], scaledLow[3], scaledHigh[3];
    for (size_t c = 0; c < 3; c++)
    {
        xMinColor[c] = clamp(((int)((xl[c] * 127.0 - p) / 2.0f + .5f)) * 2 + p,
                             p, 126 + p);
        xMaxColor[c] = clamp(((int)((xh[c] * 127.0 - p) / 2.0f + .5f)) * 2 + p,
                             p, 126 + p);

        scaledLow[c] = (xMinColor[c] << 1) | (xMinColor[c] >> 6);
        scaledHigh[c] = (xMaxColor[c] << 1) | (xMaxColor[c] >> 6)
    }

    float err = 0.0;
    for (size_t i = 0; i < 3; i++)
    {
        err += squaref((scaledLow[i] / 255.0f) - xl[i]) +
               squaref((scaledHigh[i] / 255.0f) - xh[i]);
    }

    if (err < best_err)
    {
        best_err = err;
        bestPbit = p;
        for (size_t j = 0; j < 3; j++)
        {
            bestMinColor[j] = xMinColor[j] >> 1;
            bestMaxColor[j] = xMaxColor[j] >> 1;
        }
    }
}
-----

<<<

===== Endpoint P-bits computation

This routine computes 2 optimal p-bit values per endpoint pair per subset
(BC7 modes 3, 6, and 7).

_Constants:_

[width="40%",options="header"]
|=======
| BC7 Mode | **comps** | **comp_bits**
|    3     |     3     |       7
|    6     |     4     |       7
|    7     |     4     |       5
|=======

_Inputs (for each subset):_

* *xl[comps]* and *xh[comps]* Floating-point _RGB(A)_ endpoint values ([0.0, 1.0]).

_Outputs (for each subset):_

* *bestMinColor[comps]* and *bestMaxColor[comps]* Quantized _RGB(A)_ values.
* *bestPbits[2]* P-bits to pack into BC7 output.

<<<

-----
const uint32_t total_bits = comp_bits + 1;
const int iscalep = (1 << total_bits) - 1;
const float scalep = (float)iscalep;

float best_err0 = 1e+9f;
float best_err1 = 1e+9f;

for (int p = 0; p < 2; p++)
{
    uint8_t xMinColor[comps], xMaxColor[comps], scaledLow[comps], scaledHigh[comps];
    for (size_t c = 0; c < comps; c++)
    {
        xMinColor[c] =
            (uint8_t)(clamp(((int)((xl[c] * scalep - p) / 2.0f + .5f)) * 2 + p,
                            p, iscalep - 1 + p));
        xMaxColor[c] =
            (uint8_t)(clamp(((int)((xh[c] * scalep - p) / 2.0f + .5f)) * 2 + p,
                            p, iscalep - 1 + p));

        scaledLow[c] = (xMinColor[c] << (8 - total_bits));
        scaledLow[c] |= (scaledLow[c] >> total_bits);

        scaledHigh[c] = (xMaxColor[c] << (8 - total_bits));
        scaledHigh[c] |= (scaledHigh[c] >> total_bits);
    }

    float err0 = 0.0, err1 = 0.0;
    for (size_t i = 0; i < comps; i++)
    {
        err0 += squaref(scaledLow[i] - xl[i] * 255.0f);
        err1 += squaref(scaledHigh[i] - xh[i] * 255.0f);
    }

    if (err0 < best_err0)
    {
        best_err0 = err0;
        bestPbits[0] = p;

        for (size_t i = 0; i < comps; i++)
        {
            bestMinColor[i] = xMinColor[i] >> 1;
        }
    }

    if (err1 < best_err1)
    {
        best_err1 = err1;
        best_pbits[1] = p;

        for (size_t i = 0; i < comps; i++)
        {
            bestMaxColor[i] = xMaxColor[i] >> 1;
        }
    }
}
-----

<<<

===== Weights

For most UASTC _Mode Indices_, weight indices can be copied to BC7 indices as-is.

Implementations must respect ``anchor'' indices for multi-subset BC7 modes
and swap low/high endpoint values and invert weight indices accordingly.

Although UASTC _Mode Index_ 1 has only one subset, its BC7 counterpart (mode 3)
has two subsets, so implementations may need to swap duplicated endpoints and
invert weights for the second subset.

When the number of bits per weight index is different between a given UASTC
_Mode Index_ and BC7 mode, the mappings in <<uastc-bc7-bit-weight-change>> apply.

[[uastc-bc7-bit-weight-change]]
.UASTC mapping for BC7 weights with different bit counts
[width="60%",cols="3,8*1"]
|=========
9+| *UASTC 1-bit (_Mode Index_ 13) to BC7 2-bit (mode 5)*
| ~UASTC weight~ | ~0~ | ~1~ 6.2+|
| BC7 weight     |  0  |  3
9+| *UASTC 2-bit (_Mode Index_ 14) to BC7 4-bit (mode 6)*
| ~UASTC weight~ | ~0~ | ~1~ | ~2~ | ~3~ 4.2+|
| BC7 weight     |  0  |  5  | 10  | 15
9+| *UASTC 3-bit (_Mode Index_ 5 and 12) to BC7 4-bit (mode 6)*
| ~UASTC weight~ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~
| BC7 weight     |  0  |  2  |  4  |  6  |  9  | 11  | 13  | 15
9+| *UASTC 5-bit (_Mode Index_ 18) to BC7 4-bit (mode 6)*
| ~UASTC weight~ |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~
| BC7 weight     |   0  |   0  |   1  |   1  |   2  |   2  |   3  |   3
| ~UASTC weight~ |  ~8~ |  ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| BC7 weight     |   4  |   4  |   5  |   5  |   6  |   6  |   6  |   7
| ~UASTC weight~ | ~16~ | ~17~ | ~18~ | ~19~ | ~20~ | ~21~ | ~22~ | ~23~
| BC7 weight     |   8  |   9  |   9  |   9  |  10  |  10  |  11  |  11
| ~UASTC weight~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~
| BC7 weight     |  12  |  12  |  13  |  13  |  14  |  14  |  15  |  15
|=========

===== Dual-plane blocks

UASTC dual-plane blocks are transcoded to BC7 mode 5 and utilize BC7
rotation bits to select which channel uses the second set of weights.

For _RGB_ and _RGBA_ dual-plane blocks (UASTC _Mode Indices_ 6, 11, and 13),
the value of the rotation bits depends on the *CSEL* UASTC field.
The channel that uses the second set of weights must be swapped with
alpha (within an endpoint pair) as per the BC7 specification.

[[uastc-bc7-compsel]]
.UASTC to BC7 component selection
[width="50%",options="header"]
|=========
| *CSEL*  | BC7 RB | Channel
|    0    |    1   | _Red_
|    1    |    2   | _Green_
|    2    |    3   | _Blue_
|    3    |    0   | _Alpha_
|========

For _LA_ dual-plane blocks (_Mode Index_ 17) BC7 rotation bits must be
set to 0; no channel swapping is needed.

==== Transcoding to ETC formats

UASTC blocks contain various hints to speedup transcoding to some ETC formats.
Namely:

* *UASTC to ETC1 RGB*
+
NOTE: To transcode UASTC alpha channel into a separate ETC1 texture (for example,
to provide _RGBA_ data to older hardware), transcoders would need to determine
optimal ETC1 parameters themselves.
For solid-color blocks, this could be easily accelerated with a pre-computed
lookup table.

* *UASTC to ETC2 _RGBA_ (ETC1 _RGB_ + ETC2 _Alpha_)*
+
NOTE: There are no hints for ETC2-only color modes (``T'', ``H'', or planar).
+
NOTE: Transcoding non-solid UASTC _RGB_ data to ETC2/EAC R11 (or RG11) blocks
requires full-block re-encoding.

===== Solid color blocks

For solid-color UASTC blocks, ETC1 _RGB_ transcode hints directly follow
the 32-bit _RGBA_ block color.

* *ETC1D* Color mode (0 - individual, 1 - differential).
* *ETC1I* Intensity table index. Must be used for both ETC1 subblocks.
* *ETC1S* Pixel index value to use for all 16 pixels.
* *ETC1R*, *ETC1G*, and *ETC1B* Pre-computed _RGB_ value,
  pre-quantized to 5 bits for differential color mode, or to 4 bits for
  individual color mode.
  In individual color mode, a transcoder must ignore the unused top
  bit of each channel encoding that is used to pad the representation
  to 5 bits.

A transcoder must copy these values to the appropriate fields of the ETC1
block.
For differential color mode, color delta bits must be set to 0.
For individual color mode, pre-computed _RGB_ values must be used for both
base colors.

When transcoding to ETC2 RGBA, following rules apply for the ETC2 Alpha block.

* *Base codeword* Copy from _A_ UASTC field.
* *Multiplier* 1.
* *Table index* 13.
* *All pixel indices* 4.

===== Interpolated blocks

For interpolated UASTC blocks, ETC1 _RGB_ transcode hints include:

* *ETC1F* Flip bit (0 - side-by-side, 1 - top-to-bottom).
* *ETC1D* Color mode (0 - individual, 1 - differential).
* *ETCI0* Table codeword 1.
* *ETCI1* Table codeword 2.
* *ETCBI* An optional field indicating how to bias each ETC1's subset's
  computed block color.

The UASTC block must first be unpacked to pixels.
After this, the only expensive work required to transcode to ETC1 is
computing the subblock average colors and the pixel indices.

<<<

*Subblock colors*

To compute each subblock's quantized block color for individual color mode:

1. Compute each subblock's average pixel color and quantize it to
   4-bits/component, with rounding.
   This could be done by summing 8 color values and computing (for each
   channel, with integer division):

   (sum * 15 + 1020) / (8 * 255)

2. For UASTC modes that have an *ETCBI* field, apply the ETC1 bias (as
   defined by the function below) to the result of the previous step.

3. Write the updated subblock colors to the ETC1 block.

To compute each subblock's quantized block color for differential color mode:

1. Compute each subblock's average pixel color and quantize it to
   5-bits/component, with rounding.
   This could be done by summing 8 color values and computing (for each
   channel, with integer division):

   (sum * 31 + 1020) / (8 * 255)

2. For UASTC modes that have an *ETCBI* field, apply the ETC1 bias
   (as defined by the function below) to the result of the previous step.

3. Compute the difference between the updated subblock colors
   ++(color2 - color1)++ and clamp it to a [-4, 3] 3-bit range.

4. Write the subblock color and the delta to the ETC1 block.

*Applying ETCBI*

Inputs (for each subblock):

* *subblock* Subblock index. Either 0 or 1.
* *limit* Maximum quantized color value. 31 for differential color mode, 15 for individual color mode.
* *bias* UASTC *ETCBI* field value.
* *blockColor[3]* Quantized average subblock _RGB_ color.

Outputs (for each subblock):

* *blockColor[3]* Biased subblock color value.

<<<

-----
for (uint32_t c = 0; c < 3; c++)
{
    int delta = 0;

    switch (bias)
    {
    case 2: delta = subblock ? 0 : ((c == 0) ? -1 : 0); break;
    case 5: delta = subblock ? 0 : ((c == 1) ? -1 : 0); break;
    case 6: delta = subblock ? 0 : ((c == 2) ? -1 : 0); break;

    case 7: delta = subblock ? 0 : ((c == 0) ? 1 : 0); break;
    case 11: delta = subblock ? 0 : ((c == 1) ? 1 : 0); break;
    case 15: delta = subblock ? 0 : ((c == 2) ? 1 : 0); break;

    case 18: delta = subblock ? ((c == 0) ? -1 : 0) : 0; break;
    case 19: delta = subblock ? ((c == 1) ? -1 : 0) : 0; break;
    case 20: delta = subblock ? ((c == 2) ? -1 : 0) : 0; break;

    case 21: delta = subblock ? ((c == 0) ? 1 : 0) : 0; break;
    case 24: delta = subblock ? ((c == 1) ? 1 : 0) : 0; break;
    case 8: delta = subblock ? ((c == 2) ? 1 : 0) : 0; break;

    case 10: delta = -2; break;

    case 27: delta = subblock ? 0 : -1; break;
    case 28: delta = subblock ? -1 : 1; break;
    case 29: delta = subblock ? 1 : 0; break;
    case 30: delta = subblock ? -1 : 0; break;
    case 31: delta = subblock ? 0 : 1; break;

    default:
        static const int s_divs[3] = { 1, 3, 9 };
        delta = ((bias / s_divs[c]) % 3) - 1;
        break;
    }

    int v = block_color[c];
    if (v == 0)
    {
        v = (delta == -2) ? 3 : (delta + 1);
    }
    else if (v == limit)
    {
        v += (delta - 1);
    }
    else
    {
        v += delta;
        if ((v < 0) || (v > limit))
            v = (v - delta) - delta;
    }

    block_color[c] = (uint8_t)v;
}
-----

<<<

===== Pixel indices

The last step is computing the pixel indices.
This is done by comparing decoded pixel values with 4-color palette that
is fixed for each subblock.

To accelerate this step, transcoders may compute the errors in a luma space
with _RGB_ component weights of (1, 1, 1) for linearly-encoded textures and of
(54, 183, 19) for sRGB-encoded textures.

===== ETC2/EAC _alpha_ transcoding

For UASTC _RGB_ blocks (that have fully-opaque alpha), ETC2/EAC Alpha blocks
must be encoded as:

* *Base codeword* 255.
* *Multiplier* 1.
* *Table index* 13.
* *All pixel indices* 4.

UASTC _RGBA_ modes contain two ETC2/EAC Alpha hints to accelerate transcoding
of the alpha values:

* *ETC2T* Table index.
* *ETC2M* Multiplier.
** *ETC2M* cannot be zero.
   In such a case, the block is invalid and must be decoded to the
   error color.
* When the _alpha_ value is the same for all pixels of the block and ETC2*
  hints are not used (see step 1 below), the encoder must still set *ETC2T*
  and *ETC2M* fields to 13 and 1 respectively.

*Steps for transcoding the _alpha_ channel:*

1. Compute minimum and maximum values of the block's _alpha_.
   If they are equal to each other (i.e. all pixels of the block have the
   same alpha value), the transcoding is done and the ETC2/EAC Alpha
   parameters are the same as for opaque blocks with the only difference
   that _base codeword_ must be set to the block's alpha value.

2. Compute the _base codeword_ by finding the approximate center of the
   range of alpha values for the hinted table index:
+
-----
    baseAlpha = roundf(minAlpha + (maxAlpha - minAlpha) * c)
-----
+
Where c is the floating-point value based on the table index:
+
[cols="3,8*1",width="70%"]
|===========
| ~Table index~ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~
| Float value   | 15/29 | 13/25 | 13/25 | 13/25 | 12/23 | 11/21 | 11/21 | 11/21
| ~Table index~ | ~8~ | ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| Float value   | 10/19 | 10/19 | 10/19 | 10/19 | 10/19 | 10/19 | 9/17 | 9/17
|===========

3. For each pixel, compute the pixel index that would yield lowest error with
   all other block parameters set (table index, base value, and multiplier).

4. Write all computed values to the ETC2/EAC Alpha block.

<<<

==== Transcoding to BC1-5 formats

Only BC1 (without 3-color mode) and _RGB_ parts of BC2/BC3 transcode
targets could be accelerated by using UASTC hints (BC1H0 and BC1H1).

BC4/BC5 and the _alpha_ part of BC3 always require pixel-level re-encoding.

*Using BC1 hints*

Most UASTC modes have *BC1H0* and/or *BC1H1* hint bits.
When set, they signal that some steps of a typical BC1 encoding process
could be skipped.

When the *BC1H0* bit is present and set:

* The first subset's endpoints can be scaled to BC1 range (5, 6, 5), as in
  (using integer division):
+
  R_bc1 = max((_R_ * 31 + 127) / 255, 31)
  G_bc1 = max((_G_ * 63 + 127) / 255, 63)
  B_bc1 = max((_B_ * 31 + 127) / 255, 31)
+
Other subsets (when present) can be ignored.
Note that endpoints may need to be swapped to avoid the BC1 3-color mode.

* The first plane's weight indices can be mapped to BC1 2-bit codes.
  The second plane weights (when present) are ignored.
  Note that the order of BC1 codes does not follow the order of actual
  interpolation weights, see the exact mappings in
  <<uastc-bc1-bit-weight-change>>.

* This skips the expensive PCA and least-squares steps.
  Transcoders aiming at high quality may choose to ignore this hint.

When the *BC1H1* bit is present and set:

* The first plane's weight indices can be mapped to BC1 2-bit codes.
  The second plane weights (when present) are ignored.
  Note that the order of BC1 codes does not follow the order of
  actual interpolation weights, see the exact mappings in
  <<uastc-bc1-bit-weight-change>>.

* Transcoders have to compute optimal endpoint values with pixel codes
  fixed.
  This skips the expensive PCA step.

[[uastc-bc1-bit-weight-change]]
.UASTC mapping weight indices to BC1 codes
[width="60%",cols="3,8*1"]
|=========
9+| *UASTC 1-bit weight indices to BC1 codes*
| ~UASTC weight~ | ~0~ | ~1~ 6.2+|
| BC1 code       |  0  |  1
9+| *UASTC 2-bit weight indices to BC1 codes*
| ~UASTC weight~ | ~0~ | ~1~ | ~2~ | ~3~ 4.2+|
| BC1 code       |  0  |  2  |  3  |  1
9+| *UASTC 3-bit weight indices to BC1 codes*
| ~UASTC weight~ | ~0~ | ~1~ | ~2~ | ~3~ | ~4~ | ~5~ | ~6~ | ~7~
| BC1 code       |  0  |  0  |  2  |  2  |  3  |  3  |  1  |  1
9+| *UASTC 4-bit weight indices to BC1 codes*
| ~UASTC weight~ |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~
| BC1 code       |   0  |   0  |   0  |   2  |   2  |   2  |   2  |   2
| ~UASTC weight~ |  ~8~ |  ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| BC1 code       |   3  |   3  |   3  |   3  |   3  |   1  |   1  |   1
9+| *UASTC 5-bit weight indices to BC1 codes*
| ~UASTC weight~ |  ~0~ |  ~1~ |  ~2~ |  ~3~ |  ~4~ |  ~5~ |  ~6~ |  ~7~
| BC1 code       |   0  |   0  |   0  |   0  |   0  |   0  |   2  |   2
| ~UASTC weight~ |  ~8~ |  ~9~ | ~10~ | ~11~ | ~12~ | ~13~ | ~14~ | ~15~
| BC1 code       |   2  |   2  |   2  |   2  |   2  |   2  |   2  |   2
| ~UASTC weight~ | ~16~ | ~17~ | ~18~ | ~19~ | ~20~ | ~21~ | ~22~ | ~23~
| BC1 code       |   3  |   3  |   3  |   3  |   3  |   3  |   3  |   3
| ~UASTC weight~ | ~24~ | ~25~ | ~26~ | ~27~ | ~28~ | ~29~ | ~30~ | ~31~
| BC1 code       |   3  |   3  |   1  |   1  |   1  |   1  |   1  |   1
|=========
