// Copyright (C) 2008-2015 The Khronos Group Inc. All Rights Reserved.

== S3TC Compressed Texture Image Formats

Compressed texture images stored using the S3TC compressed image formats
are represented as a collection of latexmath:[$4\times 4$] texel blocks, where each block
contains 64 or 128 bits of texel data.  The image is encoded as a normal
2D raster image in which each latexmath:[$4\times 4$] block is treated as a single pixel.
If an S3TC image has a width or height that is not a multiple of four, the
data corresponding to texels outside the image are irrelevant and
undefined.

When an S3TC image with a width of <w>, height of <h>, and block size of
<blocksize> (8 or 16 bytes) is decoded, the corresponding image size (in
bytes) is:

    ceil(<w>/4) * ceil(<h>/4) * blocksize.

When decoding an S3TC image, the block containing the texel at offset
(<x>, <y>) begins at an offset (in bytes) relative to the base of the
image of:

    blocksize * (ceil(<w>/4) * floor(<y>/4) + floor(<x>/4)).

The data corresponding to a specific texel (<x>, <y>) are extracted from a
4x4 texel block using a relative (x,y) value of

    (<x> modulo 4, <y> modulo 4).

There are four distinct S3TC image formats:

=== BC1 with no alpha

Each latexmath:[$4 \times 4$] block of texels consists of 64
bits of RGB image data.  

Each RGB image data block is encoded as a sequence of 8 bytes, called (in
order of increasing address):

        c0_lo, c0_hi, c1_lo, c1_hi, bits_0, bits_1, bits_2, bits_3

The 8 bytes of the block are decoded into three quantities:

    color0 = c0_lo + c0_hi * 256
    color1 = c1_lo + c1_hi * 256
    bits   = bits_0 + 256 * (bits_1 + 256 * (bits_2 + 256 * bits_3))

_color0_ and _color1_ are 16-bit unsigned integers that
are unpacked to RGB colors RGB0 and RGB1 as though they were 16-bit packed pixels with
the R channel in the high 5 bits, G in the next 6 bits and B in the low 5 bits.

_bits_ is a 32-bit unsigned integer, from which a two-bit control code
is extracted for a texel at location (x,y) in the block using:

    code(x,y) = bits[2*(4*y+x)+1 .. 2*(4*y+x)+0]

where bit 31 is the most significant and bit 0 is the least
significant bit.

The RGB color for a texel at location (x,y) in the block is given by:

    RGB0,              if color0 > color1 and code(x,y) == 0
    RGB1,              if color0 > color1 and code(x,y) == 1
    (2*RGB0+RGB1)/3,   if color0 > color1 and code(x,y) == 2
    (RGB0+2*RGB1)/3,   if color0 > color1 and code(x,y) == 3

    RGB0,              if color0 <= color1 and code(x,y) == 0
    RGB1,              if color0 <= color1 and code(x,y) == 1
    (RGB0+RGB1)/2,     if color0 <= color1 and code(x,y) == 2
    BLACK,             if color0 <= color1 and code(x,y) == 3

Arithmetic operations are done per component, and BLACK refers to an
RGB color where red, green, and blue are all zero.

Since this image has an RGB format, there is no alpha component and the
image is considered fully opaque.


=== BC1 with alpha

Each 4x4 block of texels consists of 64
bits of RGB image data and minimal alpha information.  The RGB components
of a texel are extracted in the same way as BC1 with no alpha.

The alpha component for a texel at location (x,y) in the block is
given by:

    0.0,               if color0 <= color1 and code(x,y) == 3
    1.0,               otherwise

// This is a discussion of the behavior of the encoder, not of the
// format itself.
//
// IMPORTANT:  When encoding an RGBA image into a format using 1-bit
// alpha, any texels with an alpha component less than 0.5 end up with an
// alpha of 0.0 and any texels with an alpha component greater than or
// equal to 0.5 end up with an alpha of 1.0.  When encoding an RGBA image
// into the COMPRESSED_RGBA_S3TC_DXT1_EXT format, the resulting red,
// green, and blue components of any texels with a final alpha of 0.0
// will automatically be zero (black).  If this behavior is not desired
// by an application, it should not use COMPRESSED_RGBA_S3TC_DXT1_EXT.
// This format will never be used when a generic compressed internal
// format (Table 3.16.2) is specified, although the nearly identical
// format COMPRESSED_RGB_S3TC_DXT1_EXT (above) may be.

The red, green, and blue components of any texels with a final alpha
of 0 should be encoded as zero (black).

=== BC2

Each 4x4 block of texels consists of 64
bits of uncompressed alpha image data followed by 64 bits of RGB image
data.  

Each RGB image data block is encoded according to the
BC1 formats, with the exception that the two code
bits always use the non-transparent encodings.  In other words, they are
treated as though color0 > color1, regardless of the actual values of
color0 and color1.

Each alpha image data block is encoded as a sequence of 8 bytes, called
(in order of increasing address):

    a0, a1, a2, a3, a4, a5, a6, a7

The 8 bytes of the block are decoded into one 64-bit integer:

    alpha = a0 + 256 * (a1 + 256 * (a2 + 256 * (a3 + 256 * (a4 +
                 256 * (a5 + 256 * (a6 + 256 * a7))))))

latexmath:[$alpha$] is a 64-bit unsigned integer, from which a four-bit alpha value
is extracted for a texel at location (x,y) in the block using:

    alpha(x,y) = bits[4*(4*y+x)+3 .. 4*(4*y+x)+0]

where bit 63 is the most significant and bit 0 is the least
significant bit.

The alpha component for a texel at location (x,y) in the block is
given by alpha(x,y) / 15.

=== BC3

Each 4x4 block of texels consists of 64
bits of compressed alpha image data followed by 64 bits of RGB image data.

Each RGB image data block is encoded according to the
BC1 formats, with the exception that the two code
bits always use the non-transparent encodings.  In other words, they are
treated as though color0 > color1, regardless of the actual values of
color0 and color1.

Each alpha image data block is encoded as a sequence of 8 bytes, called
(in order of increasing address):

    alpha0, alpha1, bits_0, bits_1, bits_2, bits_3, bits_4, bits_5

The latexmath:[$alpha0$] and latexmath:[$alpha1$] are 8-bit unsigned bytes converted to alpha
components by multiplying by 1/255.

The 6 latexmath:[$bits$] bytes of the block are decoded into one 48-bit integer:

  bits = bits_0 + 256 * (bits_1 + 256 * (bits_2 + 256 * (bits_3 + 
                  256 * (bits_4 + 256 * bits_5))))

latexmath:[$bits$] is a 48-bit unsigned integer, from which a three-bit control code
is extracted for a texel at location (x,y) in the block using:

    code(x,y) = bits[3*(4*y+x)+2 .. 3*(4*y+x)+0]

where bit 47 is the most-significant and bit 0 is the least-significant bit.

The alpha component for a texel at location (x,y) in the block is
given by:

      alpha0,                   code(x,y) == 0
      alpha1,                   code(x,y) == 1

      (6*alpha0 + 1*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 2
      (5*alpha0 + 2*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 3
      (4*alpha0 + 3*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 4
      (3*alpha0 + 4*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 5
      (2*alpha0 + 5*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 6
      (1*alpha0 + 6*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 7

      (4*alpha0 + 1*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 2
      (3*alpha0 + 2*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 3
      (2*alpha0 + 3*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 4
      (1*alpha0 + 4*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 5
      0.0,                      alpha0 <= alpha1 and code(x,y) == 6
      1.0,                      alpha0 <= alpha1 and code(x,y) == 7
